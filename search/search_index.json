{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#protocol-team-docs","title":"\ud83d\udcd1 Protocol Team Docs","text":"<p>Related documentation for Agglayer Smart Contracts and the Agglayer protocol.</p>"},{"location":"#build-documentation","title":"\ud83d\udee0\ufe0f Build Documentation","text":"<p>Documentation is available with MkDocs.</p>"},{"location":"#how-to-install-and-run","title":"\ud83d\ude80 How to Install and Run","text":"<pre><code>pip install mkdocs\npip install -r requirements.txt\nmkdocs serve\n</code></pre>"},{"location":"aggregation-layer/v0.2.0/ChangeLog/","title":"SC ChangeLog","text":"<p>This document summarizes most important changes on the SC side. You can also check the full git diff</p> <ul> <li>SC ChangeLog<ul> <li>TLDR<ul> <li>Structs</li> <li>VerifierTypes</li> <li>Events</li> <li>Functions</li> </ul> </li> <li>PolygonPessimisticConsensus.sol<ul> <li>Description</li> <li>Changes</li> </ul> </li> <li>PolygonRollupManager.sol<ul> <li>Description</li> <li>Changes<ul> <li>VerifierType</li> <li>AddNewRollupType</li> <li>verifyPessimisticTrustedAggregator</li> <li>Versioning</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"aggregation-layer/v0.2.0/ChangeLog/#tldr","title":"TLDR","text":""},{"location":"aggregation-layer/v0.2.0/ChangeLog/#structs","title":"Structs","text":"<ul> <li>Add new parameters in RollupData struct</li> <li>Add new parameters in RollupType struct</li> <li>Add helper struct RollupDataReturn to return data for StateTransistion chains to maintain backwards compatibility</li> <li>Add helper struct RollupDataReturnV2 to return all rollup data</li> </ul> <p><code>RollupDataReturnV2</code> --&gt; any software should migrate to this struct to support all rollups with all its information</p>"},{"location":"aggregation-layer/v0.2.0/ChangeLog/#verifiertypes","title":"VerifierTypes","text":"<ul> <li>Add verifiers types: StateTransition &amp; Pessimistic</li> </ul>"},{"location":"aggregation-layer/v0.2.0/ChangeLog/#events","title":"Events","text":"<ul> <li>Updated <code>AddNewRollupType</code></li> <li>Updated <code>AddExistingRollup</code></li> <li>Add <code>UpdateRollupManagerVersion</code></li> </ul>"},{"location":"aggregation-layer/v0.2.0/ChangeLog/#functions","title":"Functions","text":"<ul> <li>Updated SC function <code>addNewRollupType</code></li> <li>Updated SC function <code>addExistingRollup</code></li> <li>Add SC function to verify pessimistoc proofs <code>verifyPessimisticTrustedAggregator</code></li> <li>Add SC function <code>rollupIDToRollupData</code> to retrieve StateTransistion rollupData to maintain backwards compatibility</li> <li>Add SC function <code>rollupIDToRollupDataV2</code> to retrieve full rollupData(link)</li> </ul>"},{"location":"aggregation-layer/v0.2.0/ChangeLog/#polygonpessimisticconsensussol","title":"PolygonPessimisticConsensus.sol","text":""},{"location":"aggregation-layer/v0.2.0/ChangeLog/#description","title":"Description","text":"<p>Consensus SC to be deployed every time a new sovereign chain is created by the rollup manager. It inherits from <code>PolygonConsensusBase</code> as the other consensus implemented: <code>PolygonValidumEtrog</code> &amp; <code>PolygonZkEVMEtrog</code></p>"},{"location":"aggregation-layer/v0.2.0/ChangeLog/#changes","title":"Changes","text":"<p>It adds a new function: <code>getConsensusHash</code> <pre><code>/**\n* Note Return the necessary consensus information for the proof hashed\n*/\nfunction getConsensusHash() public view returns (bytes32) {\n    return keccak256(abi.encodePacked(CONSENSUS_TYPE, trustedSequencer));\n}\n</code></pre> Note that <code>trustedSequencer</code> address can be modified at any time by the rollup admin</p>"},{"location":"aggregation-layer/v0.2.0/ChangeLog/#polygonrollupmanagersol","title":"PolygonRollupManager.sol","text":""},{"location":"aggregation-layer/v0.2.0/ChangeLog/#description_1","title":"Description","text":"<p>Allow to create a new kind of rollupTypes based on the Verifier type. Pending states has been removed (related to decentralize aggregator) in order to clean the SC and reduce the bytecode.</p>"},{"location":"aggregation-layer/v0.2.0/ChangeLog/#changes_1","title":"Changes","text":""},{"location":"aggregation-layer/v0.2.0/ChangeLog/#verifiertype","title":"VerifierType","text":"<p>Introduced two types of Verifiers: <pre><code>enum VerifierType {\n        StateTransition,\n        Pessimistic\n    }\n</code></pre> - <code>StateTransition</code>: verifies state transition constraint function. Consensus to support this verifiers are <code>PolygonValidumEtrog</code> &amp; <code>PolygonZkEVMEWtrog</code> - <code>Pessimistic</code>: verifies the pessimisitc circuit contraints. Consensus to support this verifiers are <code>PolygonPessimisticConsensus</code></p>"},{"location":"aggregation-layer/v0.2.0/ChangeLog/#addnewrolluptype","title":"AddNewRollupType","text":"<p>Function to add new rollups has been adapted in order to support creation of new rollups with Pessimistic verifier.</p> <p>Event has been changed in order to include data related to Pessimistic verifiers: <pre><code>/**\n* @dev Emitted when a new rollup type is added\n*/\nevent AddNewRollupType(\n    uint32 indexed rollupTypeID,\n    address consensusImplementation,\n    address verifier,\n    uint64 forkID,\n    VerifierType rollupVerifierType,\n    bytes32 genesis,\n    string description,\n    bytes32 programVKey\n);\n</code></pre> New parameter <code>programVKey</code>: identifier of the program that will be proven in SP1 Verifier</p> <p>Note: If any software rely on this event it should be changed</p>"},{"location":"aggregation-layer/v0.2.0/ChangeLog/#verifypessimistictrustedaggregator","title":"verifyPessimisticTrustedAggregator","text":"<p>Function to verify Pessimsitic verifiers types. Important to notice that a chain using this verification will update its LER. Therefore, it will also update the RER and the GER. Current bridge services rely on <code>VerifyBatchesTrustedAggregator</code> event to track RER tree. Hence, same event signature has been maintained for Pessimistic verifiers <pre><code>// Same event as verifyBatches to support current bridge service to synchronize everything\nemit VerifyBatchesTrustedAggregator(\n    rollupID,\n    0, // final batch: does not apply in pessimistic\n    bytes32(0), // new state root: does not apply in pessimistic\n    newLocalExitRoot,\n    msg.sender\n);\n</code></pre></p>"},{"location":"aggregation-layer/v0.2.0/ChangeLog/#versioning","title":"Versioning","text":"<p>New constant has been added in order to check the PolygonRollupManager.sol version. <pre><code>// Current rollup manager version\n    string public constant ROLLUP_MANAGER_VERSION = \"pessimistic\";\n</code></pre> It will be updated on each upgrade.</p>"},{"location":"aggregation-layer/v0.2.0/Resources/","title":"Resources","text":"<ul> <li>zkevm-contracts PP</li> <li>SP1 Version used for PP: <code>v3.0.0</code> + <code>PLONK</code></li> <li><code>programVKey</code> could be retrieved from an aggLayer <code>VERSION</code> via:<ul> <li><code>docker run --rm -ti ghcr.io/agglayer/agglayer:VERSION /usr/local/bin/agglayer vkey</code></li> <li>available versions: https://github.com/agglayer/agglayer/pkgs/container/agglayer</li> </ul> </li> <li>SP1 Verifier deployed information</li> </ul>"},{"location":"aggregation-layer/v0.2.0/SC-Versions/","title":"SC-Tags","text":""},{"location":"aggregation-layer/v0.2.0/SC-Versions/#v900-rc4-pp","title":"v9.0.0-rc.4-pp","text":"<ul> <li>SP1Verifier from <code>v3.0.0</code> to <code>v4.0.0-rc.3</code></li> <li>Minor renaming on <code>SP1Verifier</code> --&gt; <code>SP1VerifierPlonk</code></li> </ul>"},{"location":"aggregation-layer/v0.2.0/SC-Versions/#v900-rc5-pp","title":"v9.0.0-rc.5-pp","text":"<ul> <li>add external audit document</li> <li>mainnet information upgrade</li> <li>comment on sovereign contracts</li> </ul>"},{"location":"aggregation-layer/v0.2.0/SC-Versions/#v900-rc6-pp","title":"v9.0.0-rc.6-pp","text":"<ul> <li>fix interfaces modifiers</li> <li>add contract only used for tooling, <code>BatchL2DataCreatedRollup</code></li> <li>genesis minor naming fix</li> <li>tools improvement</li> </ul>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/Intro/","title":"3.1.3.1. Introduction","text":""},{"location":"aggregation-layer/v0.2.0/SovereignChains/Intro/#tldr","title":"TLDR","text":"<ul> <li>Sovereign chains only uses pessimistic proof</li> <li>Types of Sovereign chains:<ul> <li>existing chain: deploy sovereign bridge contracts</li> <li>new chain<ul> <li>cdk-erigon client: mimic genesis cdk-erigon. Standard genesis + injected batch information</li> <li>vanilla client (op-geth): genesis with sovereign bridge contracts + initialize the bridge information (injected batch)</li> </ul> </li> </ul> </li> </ul>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/Intro/#resources","title":"Resources","text":"<ul> <li>Tool create new rollup</li> <li>SovereignBridge SC</li> </ul>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/Intro/#description","title":"Description","text":"<p>Sovereign chains refer to chains that have their own independent governance, state management, and operations while still being able to interact with other chains through the invariant/pessimistic proof for interoperability.</p> <p>Sovereign chains may rely on independent security models. They can use their own consensus mechanism but their security will only impact their own chain. They don't have to be EVM compatible as long as they have any kind of accountability of balances. For example Solana.</p>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/Intro/#types","title":"Types","text":""},{"location":"aggregation-layer/v0.2.0/SovereignChains/Intro/#existing-chains","title":"Existing chains","text":"<p>Sovereign bridge SC should be deployed on this chain in order to add BridgeLxLy functionality. cdk-component <code>agg-oracle</code> will be in charge to add/remove GERs to this chain. It is important to mention that an existing chain has its own secuencer and its own consensus.</p>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/Intro/#new-chains","title":"New chains","text":"<p>New chains will need a genesis in order to start. Depending on the client that is used, we would need to adapt the genesis creation.</p>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/Intro/#cdk-erigon","title":"cdk-erigon","text":"<p>This client works as the zkEVM was designed. Therefore, the client itself is the one that injects GER into L2 since it runs exactly the same as the executor from the zkEVM. The bridge initialization is done via the <code>injected batch</code>. The <code>injected batch</code> is synched from L1 events in a rollup chain scenario. From a sovereign chain, this data is generated when the rollup is created</p>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/Intro/#vanilla-clients","title":"vanilla clients","text":"<p>This clients do not set nativelly GER into the bridge SC. In order to achieve that, the genesis should have the <code>SovereignBridge SC</code> instead of the legacy ones with its proper initialization. Therefore, the chain will just start with a genesisj that alredy ahve the <code>SovereignBridge SC</code> and its initialization. cdk-component <code>agg-oracle</code> will be in charge to add GER to bridge</p>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/Intro/#sovereign-chains-and-the-aggregation-layer","title":"Sovereign chains and the aggregation Layer","text":"<p>Sovereign chains will be able to join the aggregation layer and share liquidity (interoperability) with other chains always secured with the invariant proof in a way where a chain can not bridge more tokens than had been claimed. This is handled by aggregation layer and SP1 proving system. In existing chains, the remapping functionality of the <code>SovereignBridge</code> will help to map other bridge tokens with the ones used by the BridgeLxLy.</p>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/Intro/#how-to-add-a-sovereign-chain-to-the-aggregation-layer","title":"How to add a sovereign chain to the aggregation layer","text":"<p>To link Sovereign chains to the aggregation layer, they should be added as a chain to Polygon's rollupManager at L1. A new rollup should be created on L1 rollup Manager at the same time that a genesis is created for the L2 chain. The genesis will mainly have a bridge and a GlobalExitRootManager to handle bridges executed from and to that network. The script to handle this process is the following: Tool create new rollup</p>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/Intro/#tldr-sc-sovereign-new-functionalities","title":"TLDR SC Sovereign new functionalities","text":"<ul> <li><code>BridgeL2SovereignChain</code> and <code>GlobalExitRootManagerL2SovereignChain</code><ul> <li>100% compatible with a vanilla client</li> <li>Allow custom implementations of ERC20s since was a feature needed for some projects (e.g USDC, Katana staking)</li> </ul> </li> <li><code>GlobalExitRootManagerL2SovereignChain</code><ul> <li>the logic change basically to allow insert GERs from the EVM, a new important event will be <code>InsertGlobalExitRoot</code></li> <li>abiltiy to delete global exit roots, new event <code>RemoveLastGlobalExitRoot</code></li> <li>bridge syncher componenets should we aware fo those events</li> </ul> </li> <li><code>BridgeL2SovereignChain</code><ul> <li>add custom erc20 implementations via the feature <code>custom mappings</code></li> <li>event <code>SetSovereignTokenAddress</code> , the bridge now will map an erc20 given a <code>uint32 originNetwork # address originTokenAddress</code>, to an address <code>sovereignTokenAddress</code> (instead of the default created by the bridge). This is important to keep track, since we will have several tokens supported on or UI, and e.g the user will want to know easily which address has USDC mainnet (originNetwork = 0, address = USDCmainnet)</li> <li><code>MigrateLegacyToken</code> scenario: default erc20 token was created <code>defaultERC20</code>. A remap <code>SetSovereignTokenAddress</code> is done for that same token. Now all the new tokens minted will be to <code>sovereignTokenAddress</code> implementation, but there are some tokens of some users on <code>defaultERC20</code>  which we call it <code>legacyToken</code>. Ww let reconvert those tokens in the bridge from those users from the legacy to the new remmaped <code>sovereignTokenaddress</code> (this event signals the scenario mentioned)</li> <li><code>RemoveLegacySovereignTokenAddress</code>: very related to the last one. Once all the tokens has been mgirated, or in some point we can \"stop support migrations\" in that moment we will call this function and this event will be emitted</li> </ul> </li> </ul>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignBridge%20SC/","title":"3.1.3.2. SovereignBridge SC","text":""},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignBridge%20SC/#bridgel2sovereignchain-smart-contract-documentation","title":"BridgeL2SovereignChain Smart Contract Documentation","text":"<p>Link SC</p> <p>Warning: This contract has not been audited. Use at your own risk.</p>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignBridge%20SC/#introduction","title":"Introduction","text":"<p>The BridgeL2SovereignChain smart contract is designed to be deployed on Ethereum and Sovereign chains. It extends the PolygonZkEVMBridgeV2 and implements the IBridgeL2SovereignChains interface. The contract manages token interactions across different networks, including token wrapping, remapping, and migration of legacy tokens.</p>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignBridge%20SC/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>State Variables</li> <li>Events</li> <li>Constructor</li> <li>Modifiers</li> <li>Functions<ul> <li>initialize</li> <li>setBridgeManager</li> <li>setMultipleSovereignTokenAddress</li> <li>setSovereignTokenAddress</li> <li>removeLegacySovereignTokenAddress</li> <li>setSovereignWETHAddress</li> <li>migrateLegacyToken</li> <li>_bridgeWrappedAsset</li> <li>_claimWrappedAsset</li> <li>activateEmergencyState</li> <li>deactivateEmergencyState</li> </ul> </li> <li>Errors</li> <li>Usage Notes</li> <li>Overview</li> <li>Deployment</li> </ul> <p>The BridgeL2SovereignChain contract acts as a bridge for token interactions between Ethereum and Sovereign chains. It handles:</p> <p>Managing token wrapping and unwrapping. Remapping tokens to new sovereign addresses. Migrating legacy tokens to updated tokens. Setting custom mappings for tokens and WETH addresses. State Variables</p> <ol> <li>wrappedAddressIsNotMintable <pre><code>mapping(address wrappedAddress =&gt; bool isNotMintable) public wrappedAddressIsNotMintable;\n</code></pre></li> <li>Description: Maps wrapped token addresses to a boolean indicating whether they are not mintable.</li> <li> <p>Usage: Determines if a wrapped token should be transferred instead of minted/burned.</p> </li> <li> <p>bridgeManager <pre><code>address public bridgeManager;\n</code></pre> Description: The address of the bridge manager who can set custom mappings for any token. Usage: Functions restricted to the bridge manager use this address for access control.</p> </li> </ol>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignBridge%20SC/#events","title":"Events","text":"<ol> <li> <p>SetBridgeManager <pre><code>event SetBridgeManager(address bridgeManager);\n</code></pre> Description: Emitted when the bridge manager is updated.</p> </li> <li> <p>SetSovereignTokenAddress <pre><code>event SetSovereignTokenAddress( uint32 originNetwork, address originTokenAddress, address sovereignTokenAddress, bool isNotMintable );\n</code></pre> Description: Emitted when a token address is remapped to a sovereign token address.</p> </li> <li> <p>MigrateLegacyToken <pre><code>event MigrateLegacyToken( address sender, address legacyTokenAddress, address updatedTokenAddress, uint256 amount );\n</code></pre> Description: Emitted when a legacy token is migrated to a new token.</p> </li> <li> <p>RemoveLegacySovereignTokenAddress <pre><code>event RemoveLegacySovereignTokenAddress(address sovereignTokenAddress);\n</code></pre> Description: Emitted when a remapped token is removed from the mapping.</p> </li> <li> <p>SetSovereignWETHAddress <pre><code>event SetSovereignWETHAddress( address sovereignWETHTokenAddress, bool isNotMintable );\n</code></pre> Description: Emitted when a WETH address is remapped to a sovereign WETH address.</p> </li> </ol>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignBridge%20SC/#constructor","title":"Constructor","text":"<p><pre><code>constructor() { _disableInitializers(); }\n</code></pre> Description: Disables initializers on the implementation contract following best practices. Note: Ensures that the contract cannot be initialized improperly.</p>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignBridge%20SC/#modifiers","title":"Modifiers","text":"<ol> <li>onlyBridgeManager <pre><code>modifier onlyBridgeManager() { if (bridgeManager != msg.sender) { revert OnlyBridgeManager(); } _; }\n</code></pre> Description: Restricts function access to the bridge manager. Usage: Applied to functions that should only be callable by the bridge manager.</li> </ol>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignBridge%20SC/#functions","title":"Functions","text":""},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignBridge%20SC/#1-initialize","title":"1. initialize","text":"<p><pre><code>function initialize( uint32 _networkID, address _gasTokenAddress, uint32 _gasTokenNetwork, IBasePolygonZkEVMGlobalExitRoot _globalExitRootManager, address _polygonRollupManager, bytes memory _gasTokenMetadata, address _bridgeManager, address _sovereignWETHAddress, bool _sovereignWETHAddressIsNotMintable ) public virtual initializer\n</code></pre> Parameters:  </p> <ul> <li>_networkID: The network ID.  </li> <li>_gasTokenAddress: The address of the gas token.  </li> <li>_gasTokenNetwork: The network ID of the gas token.  </li> <li>_globalExitRootManager: The global exit root manager address.  </li> <li>_polygonRollupManager: The rollup manager address (set to address(0) on L2).  </li> <li>_gasTokenMetadata: ABI-encoded metadata for the gas token.  </li> <li>_bridgeManager: The bridge manager address.  </li> <li>_sovereignWETHAddress: The sovereign WETH token address.  </li> <li>_sovereignWETHAddressIsNotMintable: Indicates if the WETH token is not mintable.  </li> </ul> <p>Description: Initializes the contract with the provided parameters. It sets up the gas token, WETH token, and bridge manager. If the gas token is Ether (i.e., _gasTokenAddress is address(0)), it performs specific checks and setups.</p> <p>Behavior:</p> <ul> <li>Sets the network ID, global exit root manager, and bridge manager.  </li> <li>Initializes the gas token:  </li> <li>If Ether, ensures _gasTokenNetwork is zero and no WETH address is provided.  </li> <li>If ERC20, sets up the gas token address, network, and metadata.  </li> <li>Sets up the WETH token:  </li> <li>If no _sovereignWETHAddress is provided, deploys a new wrapped token.  </li> <li>If provided, uses the given WETH address and sets its mintability.  </li> <li>Initializes OpenZeppelin contracts, such as ReentrancyGuard.  </li> </ul> <p>Notes:</p> <ul> <li>This function overrides the initializer from PolygonZkEVMBridgeV2.</li> <li>If the gas token is Ether, WETH remapping is not supported.  </li> </ul>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignBridge%20SC/#2-setbridgemanager","title":"2. setBridgeManager","text":"<pre><code>function setBridgeManager(address _bridgeManager) external onlyBridgeManager\n</code></pre> <p>Parameters:</p> <ul> <li>_bridgeManager: The new bridge manager address.  </li> </ul> <p>Description: Updates the bridge manager to a new address.</p> <p>Behavior:</p> <ul> <li>Validates that the new address is not zero.</li> <li>Updates the bridgeManager state variable.</li> <li>Emits the SetBridgeManager event.</li> </ul>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignBridge%20SC/#3-setmultiplesovereigntokenaddress","title":"3. setMultipleSovereignTokenAddress","text":"<p><pre><code>function setMultipleSovereignTokenAddress( uint32[] memory originNetworks, address[] memory originTokenAddresses, address[] memory sovereignTokenAddresses, bool[] memory isNotMintable ) external onlyBridgeManager\n</code></pre> Parameters:</p> <ul> <li>originNetworks: Array of origin network IDs.</li> <li>originTokenAddresses: Array of origin token addresses.</li> <li>sovereignTokenAddresses: Array of new sovereign token addresses.</li> <li>isNotMintable: Array of booleans indicating if each token is not mintable.</li> </ul> <p>Description: Remaps multiple wrapped tokens to new sovereign token addresses in a batch operation.</p> <p>Behavior:</p> <ul> <li>Ensures all input arrays have the same length.</li> <li>Iterates over the arrays and calls _setSovereignTokenAddress for each token.</li> </ul>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignBridge%20SC/#4-setsovereigntokenaddress","title":"4. setSovereignTokenAddress","text":"<p><pre><code>function setSovereignTokenAddress( uint32 originNetwork, address originTokenAddress, address sovereignTokenAddress, bool isNotMintable ) external onlyBridgeManager\n</code></pre> Parameters:</p> <ul> <li>originNetwork: The origin network ID.</li> <li>originTokenAddress: The origin token address (cannot be zero).</li> <li>sovereignTokenAddress: The new sovereign token address (cannot be zero).</li> <li>isNotMintable: Indicates if the token is not mintable.</li> </ul> <p>Description: Remaps a wrapped token to a new sovereign token address. Behavior: Calls _setSovereignTokenAddress internally with the provided parameters.</p>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignBridge%20SC/#5-_setsovereigntokenaddress","title":"5. _setSovereignTokenAddress","text":"<p><pre><code>function _setSovereignTokenAddress( uint32 originNetwork, address originTokenAddress, address sovereignTokenAddress, bool isNotMintable ) internal\n</code></pre> Parameters: Same as setSovereignTokenAddress. Description: Internal function that performs the actual remapping of a wrapped token to a new sovereign token address. Behavior:  </p> <ul> <li>Validates that neither originTokenAddress nor sovereignTokenAddress is zero.</li> <li>Ensures that originNetwork is not the current network ID.</li> <li>Checks that the token is not already mapped.</li> <li>Updates the mappings:<ul> <li>tokenInfoToWrappedToken with the new sovereign token address.</li> <li>wrappedTokenToTokenInfo with the token information.</li> <li>wrappedAddressIsNotMintable with the mintability status.</li> </ul> </li> <li>Emits the SetSovereignTokenAddress event.</li> </ul>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignBridge%20SC/#6-removelegacysovereigntokenaddress","title":"6. removeLegacySovereignTokenAddress","text":"<p><pre><code>function removeLegacySovereignTokenAddress( address sovereignTokenAddress ) external onlyBridgeManager\n</code></pre> Parameters:</p> <ul> <li>sovereignTokenAddress: The sovereign token address to remove from mapping.</li> </ul> <p>Description: Removes a remapped token from the mappings, effectively stopping support for the legacy sovereign token. Behavior:</p> <ul> <li>Checks that the token was previously remapped.</li> <li>Deletes the token from wrappedTokenToTokenInfo and wrappedAddressIsNotMintable.</li> <li>Emits the RemoveLegacySovereignTokenAddress event.</li> </ul>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignBridge%20SC/#7-setsovereignwethaddress","title":"7. setSovereignWETHAddress","text":"<p><pre><code>function setSovereignWETHAddress( address sovereignWETHTokenAddress, bool isNotMintable ) external onlyBridgeManager\n</code></pre> Parameters:</p> <ul> <li>sovereignWETHTokenAddress: The new sovereign WETH token address.</li> <li>isNotMintable: Indicates if the WETH token is not mintable.</li> </ul> <p>Description: Remaps the WETH token to a new sovereign WETH address. Behavior:</p> <ul> <li>Validates that the gas token is not Ether (WETH remapping is not supported on Ether networks).</li> <li>Updates the WETHToken variable with the new address.</li> <li>Updates wrappedAddressIsNotMintable with the mintability status.</li> <li>Emits the SetSovereignWETHAddress event.</li> </ul>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignBridge%20SC/#8-migratelegacytoken","title":"8. migrateLegacyToken","text":"<p><pre><code>function migrateLegacyToken( address legacyTokenAddress, uint256 amount ) external\n</code></pre> Parameters:</p> <ul> <li>legacyTokenAddress: The address of the legacy token to migrate.</li> <li>amount: The amount of tokens to migrate.</li> </ul> <p>Description: Migrates old native or remapped tokens to the new mapped tokens. If the token is mintable, it will be burned and minted; otherwise, it will be transferred. Behavior:</p> <ul> <li>Retrieves the token information for the legacy token.</li> <li>Ensures that the token is mapped.</li> <li>Retrieves the current token address from tokenInfoToWrappedToken.</li> <li>Checks that the legacy token is different from the current token.</li> <li>Calls _bridgeWrappedAsset to burn or transfer the legacy tokens from the sender.</li> <li>Calls _claimWrappedAsset to mint or transfer the new tokens to the sender.</li> <li>Emits the MigrateLegacyToken event.</li> </ul>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignBridge%20SC/#9-_bridgewrappedasset","title":"9. _bridgeWrappedAsset","text":"<p><pre><code>function _bridgeWrappedAsset( TokenWrapped tokenWrapped, uint256 amount ) internal override\n</code></pre> Parameters:</p> <ul> <li>tokenWrapped: The wrapped token to burn or transfer.</li> <li>amount: The amount of tokens.</li> </ul> <p>Description: Burns tokens from the wrapped token to execute the bridge. If the token is not mintable, it transfers the tokens instead. Behavior:</p> <ul> <li>Checks wrappedAddressIsNotMintable for the token address.</li> <li>If not mintable, transfers the tokens from the sender to the contract.</li> <li>If mintable, burns the tokens from the sender.</li> </ul>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignBridge%20SC/#10-_claimwrappedasset","title":"10. _claimWrappedAsset","text":"<p><pre><code>function _claimWrappedAsset( TokenWrapped tokenWrapped, address destinationAddress, uint256 amount ) internal override\n</code></pre> Parameters:</p> <ul> <li>tokenWrapped: The wrapped token to mint or transfer.</li> <li>destinationAddress: The address to receive the tokens.</li> <li>amount: The amount of tokens.</li> </ul> <p>Description: Mints tokens from the wrapped token to proceed with the claim. If the token is not mintable, it transfers the tokens instead.  </p> <p>Behavior:</p> <ul> <li>Checks wrappedAddressIsNotMintable for the token address.</li> <li>If not mintable, transfers the tokens to the destinationAddress.</li> <li>If mintable, mints the tokens to the destinationAddress.</li> </ul>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignBridge%20SC/#11-activateemergencystate","title":"11. activateEmergencyState","text":"<p><pre><code>function activateEmergencyState() external override(IPolygonZkEVMBridgeV2, PolygonZkEVMBridgeV2)\n</code></pre> Description: Overrides the function to prevent activation of the emergency state. Reverts when called. Behavior: Always reverts with NotValidBridgeManager().</p>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignBridge%20SC/#12-deactivateemergencystate","title":"12. deactivateEmergencyState","text":"<p><pre><code>function deactivateEmergencyState() external override(IPolygonZkEVMBridgeV2, PolygonZkEVMBridgeV2)\n</code></pre> Description: Overrides the function to prevent deactivation of the emergency state. Reverts when called. Behavior: Always reverts with NotValidBridgeManager().</p>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignBridge%20SC/#errors","title":"Errors","text":"<ul> <li>OnlyBridgeManager(): Thrown when a function is called by an address that is not the bridge manager.</li> <li>NotValidBridgeManager(): Thrown when the bridge manager address is invalid (e.g., zero address).</li> <li>InvalidZeroAddress(): Thrown when a zero address is provided where it is not allowed.</li> <li>OriginNetworkInvalid(): Thrown when the origin network ID is the same as the current network ID.</li> <li>TokenAlreadyMapped(): Thrown when attempting to map a token that is already mapped.</li> <li>TokenNotRemapped(): Thrown when attempting to remove a token that was not remapped.</li> <li>InputArraysLengthMismatch(): Thrown when input arrays in a function have mismatched lengths.</li> <li>TokenNotMapped(): Thrown when attempting to migrate a token that is not mapped.</li> <li>TokenAlreadyUpdated(): Thrown when the token to migrate is already updated.</li> <li>InvalidInitializeFunction(): Thrown when an invalid initialize function is called.</li> <li>GasTokenNetworkMustBeZeroOnEther(): Thrown when the gas token network is not zero while the gas token is Ether.</li> <li>InvalidSovereignWETHAddressParams(): Thrown when invalid parameters are provided for the sovereign WETH address.</li> <li>WETHRemappingNotSupportedOnGasTokenNetworks(): Thrown when attempting to remap WETH on networks where the gas token is Ether.</li> </ul>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignBridge%20SC/#usage-notes","title":"Usage Notes","text":"<ul> <li>Bridge Manager: Only the bridge manager can call functions that change the state mappings or manager address.</li> <li>Token Remapping: When remapping tokens, ensure that the origin network ID is different from the current network ID and that the token addresses are valid.</li> <li>Mintability: The isNotMintable flag indicates whether tokens should be transferred instead of minted/burned. This is important for tokens that do not support minting or burning.</li> <li>Legacy Token Migration: Users can migrate legacy tokens to new tokens if they have been remapped by the bridge manager.</li> <li>Emergency State: Activation and deactivation of the emergency state are intentionally disabled in this contract.</li> </ul> <p>Disclaimer: This documentation is provided for informational purposes only and may not cover all aspects of the contract. Always review the contract code thoroughly before interacting with it.</p>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignBridge%20SC/#docker-build","title":"Docker build","text":"<ul> <li>Set params at <code>create_rollup_parameters_docker.json</code></li> </ul> <pre><code>\"isVanillaClient\": false, // If true, sovereignParams are mandatory\n    \"sovereignParams\": {\n        \"bridgeManager\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\", // Address pf the bridge manager\n        \"sovereignWETHAddress\": \"0x0000000000000000000000000000000000000000\", // Address of the sovereign WETH address, zero if not applies\n        \"sovereignWETHAddressIsNotMintable\": false, // is sovereign WETH address mintable? False if not applies\n        \"globalExitRootUpdater\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\" // Address of the global Exit root admin\n    }\n</code></pre> <ul> <li><code>npm run dockerv2:contracts</code></li> </ul>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignGERManager%20SC/","title":"3.1.3.3. SovereignGERManager SC","text":""},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignGERManager%20SC/#globalexitrootmanagerl2sovereignchain-smart-contract-documentation","title":"GlobalExitRootManagerL2SovereignChain Smart Contract Documentation","text":"<p>Link SC</p> <p>Warning: This contract has not been audited. Use at your own risk.</p>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignGERManager%20SC/#introduction","title":"Introduction","text":"<p>The GlobalExitRootManagerL2SovereignChain smart contract is designed to manage exit roots for Sovereign chains and global exit roots. It extends the PolygonZkEVMGlobalExitRootL2 contract and implements the Initializable interface from OpenZeppelin. The contract allows authorized parties to insert and remove global exit roots, maintaining a mapping of these roots with an insertion order.</p>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignGERManager%20SC/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>State Variables</li> <li>Events</li> <li>Constructor</li> <li>Modifiers</li> <li>Functions<ul> <li>initialize</li> <li>insertGlobalExitRoot</li> <li>removeLastGlobalExitRoots</li> </ul> </li> <li>Errors</li> <li>Usage Notes</li> <li>Disclaimer</li> <li>Overview</li> </ul> <p>The GlobalExitRootManagerL2SovereignChain contract serves as a manager for global exit roots in the context of Sovereign chains. It allows a designated globalExitRootUpdater to insert new global exit roots and remove the last inserted ones. This contract ensures the integrity and order of global exit roots, which are crucial for cross-chain interactions and validations.</p>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignGERManager%20SC/#state-variables","title":"State Variables","text":""},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignGERManager%20SC/#globalexitrootupdater","title":"globalExitRootUpdater","text":"<p><pre><code>address public globalExitRootUpdater;\n</code></pre> Description: The address authorized to insert and remove global exit roots. If set to the zero address, the block.coinbase address is used as the updater. Usage: Functions restricted to the global exit root updater use this address for access control.</p>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignGERManager%20SC/#insertedgercount","title":"insertedGERCount","text":"<p><pre><code>uint256 public insertedGERCount;\n</code></pre> Description: A counter tracking the total number of inserted global exit roots. Usage: Helps maintain the insertion order of global exit roots and ensures correct removal of the last inserted roots.</p>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignGERManager%20SC/#events","title":"Events","text":"<ol> <li>InsertGlobalExitRoot <pre><code>event InsertGlobalExitRoot(bytes32 indexed newGlobalExitRoot);\n</code></pre> Description: Emitted when a new global exit root is inserted. Parameters:</li> <li> <p>newGlobalExitRoot: The hash of the newly inserted global exit root.</p> </li> <li> <p>RemoveLastGlobalExitRoot <pre><code>event RemoveLastGlobalExitRoot(bytes32 indexed removedGlobalExitRoot);\n</code></pre> Description: Emitted when the last inserted global exit root is removed. Parameters:</p> </li> <li>removedGlobalExitRoot: The hash of the removed global exit root.</li> </ol>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignGERManager%20SC/#constructor","title":"Constructor","text":"<p><pre><code>constructor(address _bridgeAddress) PolygonZkEVMGlobalExitRootL2(_bridgeAddress) { _disableInitializers(); }\n</code></pre> Parameters: * _bridgeAddress: The address of the PolygonZkEVMBridge contract.</p> <p>Description: Initializes the contract by calling the parent constructor with the provided bridge address and disables further initializations. Note: Ensures that the contract cannot be improperly initialized again.</p>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignGERManager%20SC/#modifiers","title":"Modifiers","text":"<ol> <li>onlyGlobalExitRootUpdater <pre><code>modifier onlyGlobalExitRootUpdater() {\n    if (globalExitRootUpdater == address(0)) {\n        if (block.coinbase != msg.sender) {\n            revert OnlyGlobalExitRootUpdater();\n        }\n    } else {\n        if (globalExitRootUpdater != msg.sender) {\n            revert OnlyGlobalExitRootUpdater();\n        }\n    }\n    _;\n}\n</code></pre> Description: Restricts function access to the globalExitRootUpdater. Behavior:</li> <li>If globalExitRootUpdater is set to the zero address (address(0)), only the block.coinbase address can call the function.</li> <li>Otherwise, only the address stored in globalExitRootUpdater can call the function.</li> </ol> <p>Usage: Applied to functions that should only be callable by the global exit root updater.</p>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignGERManager%20SC/#functions","title":"Functions","text":"<ol> <li>initialize <pre><code>function initialize(address _globalExitRootUpdater) external virtual initializer\n</code></pre> Parameters:</li> <li>_globalExitRootUpdater: The address to be set as the global exit root updater. Description: Initializes the contract by setting the globalExitRootUpdater address. Behavior:</li> <li>Sets the globalExitRootUpdater state variable.</li> <li>Marks the contract as initialized to prevent re-initialization.</li> </ol> <p>Notes: This function is marked with the initializer modifier to ensure it can only be called once.</p> <ol> <li>insertGlobalExitRoot <pre><code>function insertGlobalExitRoot(bytes32 _newRoot) external onlyGlobalExitRootUpdater\n</code></pre> Parameters:</li> <li>_newRoot: The new global exit root to insert. Description: Inserts a new global exit root into the mapping and increments the insertion count. Behavior:</li> <li>Checks if the _newRoot has already been inserted by verifying globalExitRootMap[_newRoot].</li> <li>If not inserted, increments insertedGERCount and updates the mapping.</li> <li>Emits the InsertGlobalExitRoot event.</li> <li>If already inserted, reverts with GlobalExitRootAlreadySet().</li> <li> <p>Access Control: Restricted to the globalExitRootUpdater via the onlyGlobalExitRootUpdater modifier.</p> </li> <li> <p>removeLastGlobalExitRoots ``` function removeLastGlobalExitRoots(bytes32[] calldata gersToRemove) external onlyGlobalExitRootUpdater ````</p> </li> </ol> <p>Parameters: * gersToRemove: An array of global exit roots to remove. The array should be in the order of insertion, with the first element being the last inserted root.</p> <p>Description: Removes the last inserted global exit roots specified in the array. Behavior: * Checks if there are enough inserted roots to remove the requested number by comparing gersToRemove.length with insertedGERCount. * Iterates over gersToRemove:     * Verifies that each root to remove is indeed the last inserted by checking globalExitRootMap[rootToRemove] == insertedGERCountCache.     * If verification passes, deletes the root from the mapping and decrements insertedGERCount.     * Emits the RemoveLastGlobalExitRoot event for each removed root. * If any root is not the last inserted, reverts with NotLastInsertedGlobalExitRoot(). * If there are not enough roots to remove, reverts with NotEnoughGlobalExitRootsInserted(). * Access Control: Restricted to the globalExitRootUpdater via the onlyGlobalExitRootUpdater modifier.</p>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignGERManager%20SC/#errors","title":"Errors","text":"<ul> <li>OnlyGlobalExitRootUpdater(): Thrown when a function is called by an address that is not authorized as the global exit root updater.</li> <li>GlobalExitRootAlreadySet(): Thrown when attempting to insert a global exit root that has already been inserted.</li> <li>NotEnoughGlobalExitRootsInserted(): Thrown when attempting to remove more global exit roots than have been inserted.</li> <li>NotLastInsertedGlobalExitRoot(): Thrown when attempting to remove a global exit root that is not the last inserted one.</li> </ul>"},{"location":"aggregation-layer/v0.2.0/SovereignChains/SovereignGERManager%20SC/#usage-notes","title":"Usage Notes","text":"<ul> <li>Global Exit Root Updater: The globalExitRootUpdater plays a crucial role in managing global exit roots. It can be set to a specific address or left as the zero address. When set to zero, the block.coinbase (the miner or validator who mined the block) becomes the authorized updater.</li> <li>Insertion Order: The contract maintains an insertion order for global exit roots using the insertedGERCount. This ensures that only the last inserted roots can be removed, preserving the integrity of the exit root sequence.</li> <li>Access Control: Functions that modify the state of global exit roots are protected by the onlyGlobalExitRootUpdater modifier to prevent unauthorized access.</li> <li>Initialization: The initialize function must be called after deployment to set the globalExitRootUpdater. This function can only be called once due to the initializer modifier.</li> <li>Error Handling: The contract uses custom errors to provide more efficient and informative error handling. These errors should be handled appropriately when interacting with the contract.</li> </ul> <p>Disclaimer: This documentation is provided for informational purposes only and may not cover all aspects of the contract. Always review the contract code thoroughly before interacting with it.</p>"},{"location":"aggregation-layer/v0.3.0/Changes-v0.3.1/","title":"Changes v0.3.0 --&gt; v0.3.1","text":""},{"location":"aggregation-layer/v0.3.0/Changes-v0.3.1/#motivation","title":"Motivation","text":"<p>The motivation behind these changes is to enable the upgrade of a zkEVM rollup to a pessimistic consensus rollup (PP).</p> <p>Our goal has been to introduce this functionality with minimal modifications across all system components. To support this transition, we designed a migration mechanism that integrates smoothly into the current rollup architecture.</p> <p>Specifically, we added a new function to initiate the migration process, and structured the system so that the migration is automatically finalized upon the successful verification of the first proof following the upgrade. This ensures consistency and security during the transition while maintaining alignment with existing rollup lifecycle flows.</p>"},{"location":"aggregation-layer/v0.3.0/Changes-v0.3.1/#sources","title":"Sources","text":"<ul> <li>New TAG</li> <li>Git diff PR</li> <li>Git diff v10.1.0-rc.5 - v11.0.0-rc.2</li> </ul>"},{"location":"aggregation-layer/v0.3.0/Changes-v0.3.1/#contract-updates-for-migration-to-pessimistic-proof-pp","title":"Contract Updates for Migration to Pessimistic Proof (PP)","text":"<p>This update introduces a new version (<code>al-v0.3.1</code>) of the <code>PolygonRollupManager</code> contract, focusing on enabling rollup migrations from a state transition system to a pessimistic proof (PP) system. The following core updates were implemented:</p> <p>This update (version <code>al-v0.3.1</code>) of the PolygonRollupManager contract includes extended functionality to support the migration of rollups from a standard state transition mechanism (ZK) to a pessimistic proof (PP) system. The following components and logic were added or updated to enable this capability:</p>"},{"location":"aggregation-layer/v0.3.0/Changes-v0.3.1/#new-mapping-and-events","title":"New Mapping and Events:","text":"<ul> <li> <p><code>isRollupMigrating</code>: A new mapping has been added to keep track of rollups that are in the process of migrating.</p> </li> <li> <p><code>InitMigration</code> and <code>CompletedMigration</code>: Two events are emitted to signal the start and completion of the migration flow, respectively.</p> </li> </ul> <pre><code>    /**\n     * @dev Emitted when `initMigration` is called\n     * @param rollupID Rollup ID that is being migrated\n     * @param newRollupTypeID New rollup type ID that the rollup will be migrated to\n     */\n    event InitMigration(uint32 indexed rollupID, uint32 newRollupTypeID);\n\n    /**\n     * @dev Emitted when a rollup completes the migration to Pessimistic or ALGateway, just after proving bootstrapped batch\n     * @param rollupID Rollup ID that completed the migration\n     */\n    event CompletedMigration(uint32 indexed rollupID);  \n</code></pre>"},{"location":"aggregation-layer/v0.3.0/Changes-v0.3.1/#flow-migration","title":"Flow migration","text":"<p>The migration flow can be found explained in this section: flow migration.</p>"},{"location":"aggregation-layer/v0.3.0/Changes-v0.3.1/#new-error-conditions","title":"New Error Conditions","text":"<ul> <li><code>NewRollupTypeMustBePessimisticOrALGateway</code>: Thrown when trying to migrate a rollup to a non pessimistic or ALGateway rollup type with <code>initMigration</code> function.</li> <li><code>InvalidNewLocalExitRoot</code>: Thrown when trying to finish a migration of a rollup to a pessimistic rollup type with <code>verifyPessimisticTrustedAggregator</code> function and the proposed new local exit root does not match the expected new local exit root.</li> </ul>"},{"location":"aggregation-layer/v0.3.0/Changes-v0.3.1/#remedations-audit","title":"Remedations audit","text":"<ul> <li>Comment localExitRoot: add new comment</li> <li>Renamed legacy vars function rollupIDToRollupDataDeserialized</li> <li>Unifying logic sequenced batches check</li> </ul>"},{"location":"aggregation-layer/v0.3.0/Changes-v0.3.1/#internal-audit-fixes","title":"Internal audit fixes","text":"<p>Commit with follow changes:</p> <ul> <li>Typo in comment</li> <li>Update <code>reinitializer(4)</code> -&gt; <code>reinitializer(5)</code></li> </ul>"},{"location":"aggregation-layer/v0.3.0/Changes-v0.3.1/#check-global-index","title":"Check global index","text":"<p>It has been detected that a new check is necessary for the <code>globalIndex</code> to ensure that unused bits are set to 0. Commit with new check for global index in internal function <code>_verifyLeaf</code>:</p> <ul> <li>If <code>globalIndex &amp; _GLOBAL_INDEX_MAINNET_FLAG != 0</code> check all unused bits are 0 with: <pre><code>require(\n    _GLOBAL_INDEX_MAINNET_FLAG + uint256(leafIndex) == globalIndex,\n    InvalidGlobalIndex()\n);\n</code></pre></li> <li>Else, check all unused bits bits are 0 with: <pre><code>require(\n    (uint256(indexRollup) &lt;&lt; uint256(32)) + uint256(leafIndex) == globalIndex,\n    InvalidGlobalIndex()\n);\n</code></pre></li> <li>Add new error for this check: <pre><code>/**\n * @dev Thrown when the global index has any unused bits set to 1\n*/\nerror InvalidGlobalIndex();\n</code></pre></li> </ul>"},{"location":"aggregation-layer/v0.3.0/Changes-v0.3.1/#push-claim-event","title":"Push Claim Event","text":"<p>Commit with fix for reentrancy call: Now, the event will occur before the call. This way, there won\u2019t be an ordering error if there is reentrancy.</p> <ul> <li>Before: <pre><code>- call function\n- SC call reentrancy\n- ClaimEvent\n</code></pre></li> <li>Now: <pre><code>- call function\n- ClaimEvent\n- SC call reentrancy\n</code></pre></li> </ul>"},{"location":"aggregation-layer/v0.3.0/Changes-v0.3.1/#tools","title":"Tools","text":"<ul> <li>e2e instructions</li> <li>upgrade script</li> <li>migate SC call </li> </ul>"},{"location":"aggregation-layer/v0.3.0/Diagrams/","title":"Flows","text":""},{"location":"aggregation-layer/v0.3.0/Diagrams/#add-new-aggchain-fep","title":"Add new Aggchain FEP","text":"<p>Here's the flow that needs to be followed to add a new aggchain (in this case, an AggchainFEP):</p> Flow add new AggchainFEP"},{"location":"aggregation-layer/v0.3.0/Diagrams/#addnewrolluptype","title":"addNewRollupType","text":"<p>First step a new rollup type is added. This tool will be used to do it.</p> <p>Following the next README, a new rollup type is added by calling the <code>addNewRollupType</code> function of <code>PolygonRollupManager</code> contract. Once called, the <code>rollupTypeID</code> parameter will be obtained and should be used in the following tool.</p>"},{"location":"aggregation-layer/v0.3.0/Diagrams/#attachaggchaintoal","title":"attachAggchainToAL","text":"<p>The second step is to create a new chain with the rollup type we created earlier. This tool will be used to do it.</p> <p>The following README can be followed to create the new <code>AggchainFEP</code> by calling the <code>attachAggchainToAL</code> function, using the <code>rollupTypeID</code> created with the previous tool.</p>"},{"location":"aggregation-layer/v0.3.0/Diagrams/#add-vkeys-to-agglayergateway","title":"add vkeys to AggLayerGateway","text":"<p>The third step is to initialize the vkeys in <code>AggLayerGateway</code> contract:</p> <ul> <li>This tool is used to add the pessimistic vkey route (<code>addPessimisticVKeyRoute</code>).</li> <li>This tool is used to add the aggchain vkey (<code>addDefaultAggchainVKey</code>).</li> </ul>"},{"location":"aggregation-layer/v0.3.0/Diagrams/#update-v020-ecdsa-to-v030-fep","title":"Update v0.2.0-ECDSA to v0.3.0-FEP","text":"Flow update to AggchainFEP"},{"location":"aggregation-layer/v0.3.0/Diagrams/#addnewrolluptype_1","title":"addNewRollupType","text":"<p>First step a new rollup type is added. This tool will be used to do it.</p> <p>Following the next README, a new rollup type is added by calling the <code>addNewRollupType</code> function of <code>PolygonRollupManager</code> contract. Once called, the <code>rollupTypeID</code> parameter will be obtained and should be used in the following tool.</p>"},{"location":"aggregation-layer/v0.3.0/Diagrams/#updaterollup","title":"updateRollup","text":"<p>The second step is to update the old rollup to the new rollup type that was created with the previous tool. This tool will be used to do it.</p> <p>The following README can be followed to update the old rollup to the new rollup type created with the previous tool by calling the <code>updateRollup</code> function, using the <code>rollupTypeID</code> created with the previous tool.</p>"},{"location":"aggregation-layer/v0.3.0/Diagrams/#add-vkeys-to-agglayergateway_1","title":"add vkeys to AggLayerGateway","text":"<p>The third step is to initialize the vkeys in <code>AggLayerGateway</code> contract:</p> <ul> <li>This tool is used to add the pessimistic vkey route (<code>addPessimisticVKeyRoute</code>).</li> <li>This tool is used to add the aggchain vkey (<code>addDefaultAggchainVKey</code>).</li> </ul>"},{"location":"aggregation-layer/v0.3.0/Diagrams/#verify-fep","title":"Verify FEP","text":""},{"location":"aggregation-layer/v0.3.0/Diagrams/#data-schemas","title":"Data Schemas","text":"<p>To better understand the verification flow, it is important to first understand the structure of the data involved. The following section outlines the three core data schemas that are used throughout the process. Each schema defines a specific data format that plays a critical role in different stages of the verification logic.</p>"},{"location":"aggregation-layer/v0.3.0/Diagrams/#proof","title":"Proof","text":"<p>This is how the proof is constructed:</p> proof <p>You can find the full information of the proof we use for verification in this spec.</p>"},{"location":"aggregation-layer/v0.3.0/Diagrams/#aggchaindata-fep","title":"AggchainData FEP","text":"<p>Specific custom data used to verify Aggregation Layer chains. This data is used, for example, in the <code>getAggchainHash</code> function and to extract the necessary information required during the verification process.</p> aggchainData <p>You can find more details about this AggchainData for FEP in this link.</p>"},{"location":"aggregation-layer/v0.3.0/Diagrams/#aggchainvkeyselector","title":"AggchainVKeySelector","text":"<p>This is part of the <code>AggchainData</code>. We use it to determine the <code>aggchainVKey</code>, which is then used in the computation of the <code>getAggchainHash</code> function. The following diagram shows how this selector is built:</p> aggchainVKeySelector <p>For more information, see this link.</p>"},{"location":"aggregation-layer/v0.3.0/Diagrams/#flow-diagram","title":"Flow diagram","text":"<p>The following diagram aims to illustrate the flow of data during a verification process.</p> <p>Note: Before the flow itself begins, the first essential step is to register a route in the AgglayerGateway contract using the addPessimisticVKeyRoute function. This setup step is not part of the flow per se but is a prerequisite for the rest of the process.</p> Verify pessimistic proof <p>The process starts with a call to the <code>verifyPessimisticTrustedAggregator</code> function.</p> <p>Inside this function, the <code>getInputPessimisticBytes</code> function is called.</p> <p>As part of its execution, the <code>getAggchainHash</code> function is invoked. The <code>getAggchainHash</code> function uses the <code>aggchainData</code> to compute the hash.</p> <p>Once the <code>inputPessimisticBytes</code> are obtained, and along with the proof we previously described, the verification call is forwarded to the <code>AgglayerGateway</code> with function <code>verifyPesimissticProof</code>.</p> <p>Within the <code>AgglayerGateway</code> , the <code>ppSelector</code> extracted from the proof is used to correctly route the call to the appropriate verifier.</p> <p>If the verification succeeds:</p> <ul> <li>The <code>updateExitRoot</code> function is called..</li> <li>Then, using the <code>aggchainData</code>, the <code>onVerifyPessimistic</code> function of the corresponding Aggchain contract is called.</li> <li>This function emits <code>OutputProposed</code> event.</li> </ul>"},{"location":"aggregation-layer/v0.3.0/Diagrams/#migration-to-pp-or-algateway","title":"Migration to PP or ALGateway","text":""},{"location":"aggregation-layer/v0.3.0/Diagrams/#migration-initialization","title":"Migration Initialization","text":"<p>A new function, <code>initMigration</code>, enables the explicit start of a migration process.</p> <p>This function performs checks to ensure:</p> <ul> <li>It checks that the current <code>rollupVerifierType</code> is <code>StateTransition</code>, confirming the rollup originates from the legacy system.</li> <li>It ensures there are no pending batches left unverified before initiating the migration.</li> <li>It enforces that the new <code>rollupVerifierType</code> being set is <code>PP</code> or <code>ALGateway</code>.</li> <li>Finally, it calls the internal <code>_updateRollup</code> function to execute the migration. To support this, the internal check in <code>updateRollup</code> that restricted updates to only the same verifier type or ALGateway was removed. This restriction has been relocated to the public functions, allowing internal reuse of <code>updateRollup</code> for all update flows\u2014including migrations\u2014while preserving proper guard conditions.</li> </ul>"},{"location":"aggregation-layer/v0.3.0/Diagrams/#proof-verification-during-migration","title":"Proof Verification During Migration","text":"<p>The <code>verifyPessimisticTrustedAggregator</code> function was adjusted to support special cases that occur during the migration process.</p> <ul> <li>It now allows the verification of bootstrap certificates, which are required to validate the first proof after switching to the new system.</li> <li>It's a hard requirement that the <code>newLocalExitRoot</code> matches the current <code>lastLocalExitRoot</code> meaning that the certificates covers all the bridges <p>If the rollup has never verifed a batch with bridges, the expected <code>newLocalExitRoot</code> must be to root of an empty 32 levels tree</p> </li> <li>These changes ensure that proofs submitted during migration are processed correctly without breaking the existing logic.</li> </ul>"},{"location":"aggregation-layer/v0.3.0/Diagrams/#flow-migration","title":"Flow migration","text":"Flow migration"},{"location":"aggregation-layer/v0.3.0/Diagrams/#addnewrolluptype_2","title":"addNewRollupType","text":"<p>First step a new rollup type is added. This tool will be used to do it.</p> <p>Following the next README, a new rollup type is added by calling the <code>addNewRollupType</code> function of <code>PolygonRollupManager</code> contract. Once called, the <code>rollupTypeID</code> parameter will be obtained and should be used in the following tool.</p>"},{"location":"aggregation-layer/v0.3.0/Diagrams/#initmigration","title":"initMigration","text":"<p>To initiate the migration, this tool can be used: initMigration tool We will see that an event indicating the migration has been initialized is emitted (<code>InitMigration</code>). Finally, when the verification is done with <code>verifyPessimisticTrustedAggregator</code>, an event indicating that the migration has been completed will be emitted (<code>CompletedMigration</code>).</p>"},{"location":"aggregation-layer/v0.3.0/Docker/","title":"Docker documentation","text":"<p>By default the following mnemonic will be used to deploy the smart contracts <code>MNEMONIC=\"test test test test test test test test test test test junk\"</code>. Also the first 20 accounts of this mnemonic will be funded with ether. The first account of the mnemonic will be the deployer of the smart contracts and therefore the holder of all the MATIC test tokens, which are necessary to pay the <code>sendBatch</code> transactions. You can change the deployment <code>mnemonic</code> creating a <code>.env</code> file in the project root with the following variable: <code>MNEMONIC=&lt;YOUR_MENMONIC&gt;</code></p>"},{"location":"aggregation-layer/v0.3.0/Docker/#1-requirements","title":"1. Requirements","text":"<ul> <li>node version: 14.x</li> <li>npm version: 7.x</li> <li>docker</li> <li>docker-compose</li> </ul>"},{"location":"aggregation-layer/v0.3.0/Docker/#2-config-files","title":"2. Config files","text":"<p>In the case of the Docker deployment, we are going to take the default configuration files that we have in this folder.</p>"},{"location":"aggregation-layer/v0.3.0/Docker/#21-deploy_parametersjson","title":"2.1. deploy_parameters.json","text":""},{"location":"aggregation-layer/v0.3.0/Docker/#211-docker-config-file","title":"2.1.1. Docker config file","text":"<pre><code>{\n \"test\": true,\n \"timelockAdminAddress\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\",\n \"minDelayTimelock\": 3600,\n \"salt\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n \"initialZkEVMDeployerOwner\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\",\n \"admin\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\",\n \"trustedAggregator\": \"0x70997970C51812dc3A010C7d01b50e0d17dc79C8\",\n \"trustedAggregatorTimeout\": 604799,\n \"pendingStateTimeout\": 604799,\n \"emergencyCouncilAddress\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\",\n \"polTokenAddress\": \"\",\n \"zkEVMDeployerAddress\": \"\",\n \"deployerPvtKey\": \"\",\n \"maxFeePerGas\": \"\",\n \"maxPriorityFeePerGas\": \"\",\n \"multiplierGas\": \"\"\n}\n</code></pre>"},{"location":"aggregation-layer/v0.3.0/Docker/#212-description","title":"2.1.2. Description","text":"<ul> <li><code>test</code>: bool, Indicate if it's a test deployment, which will fund the deployer address with pre minted ether and will give more powers to the deployer address to make easier the flow.</li> <li><code>timelockAdminAddress</code>: address, Timelock owner address, able to send start an upgradeability process via timelock</li> <li><code>minDelayTimelock</code>: number, Minimum timelock delay,</li> <li><code>salt</code>: bytes32, Salt used in <code>PolygonZkEVMDeployer</code> to deploy deterministic contracts, such as the PolygonZkEVMBridge</li> <li><code>initialZkEVMDeployerOwner</code>: address, Initial owner of the <code>PolygonZkEVMDeployer</code></li> <li><code>admin</code>: address, Admin address, can adjust RollupManager parameters or stop the emergency state</li> <li><code>trustedAggregator</code>: address, Trusted aggregator address</li> <li><code>trustedAggregatorTimeout</code>: uint64, If a sequence is not verified in this timeout everyone can verify it</li> <li><code>pendingStateTimeout</code>: uint64, Once a pending state exceeds this timeout it can be consolidated by everyone</li> <li><code>emergencyCouncilAddress</code>: address, Emergency council address</li> <li><code>polTokenAddress</code>: address, POL token address, only if deploy on testnet can be left blank and will fulfilled by the scripts.</li> <li><code>zkEVMDeployerAddress</code>: address, Address of the <code>PolygonZkEVMDeployer</code>. Can be left blank, will be fulfilled automatically with the <code>deploy:deployer:ZkEVM:goerli</code> script.</li> <li><code>ppVKey</code>: pessimistic program verification key (AggLayerGateway)</li> <li><code>ppVKeySelector</code>:  The 4 bytes selector to add to the pessimistic verification keys (AggLayerGateway)</li> <li><code>realVerifier</code>: bool, Indicates whether deploy a real verifier or not (AggLayerGateway)</li> </ul>"},{"location":"aggregation-layer/v0.3.0/Docker/#22-create_rollup_parametersjson","title":"2.2. create_rollup_parameters.json","text":""},{"location":"aggregation-layer/v0.3.0/Docker/#221-docker-config-file-fep-by-default","title":"2.2.1. Docker config file (FEP, by default)","text":"<pre><code>{\n    \"realVerifier\": false,\n    \"trustedSequencerURL\": \"http://zkevm-json-rpc:8123\",\n    \"networkName\": \"zkevm\",\n    \"description\": \"0.0.1\",\n    \"trustedSequencer\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\",\n    \"chainID\": 1001,\n    \"adminZkEVM\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\",\n    \"forkID\": 0,\n    \"consensusContract\": \"AggchainFEP\",\n    \"gasTokenAddress\": \"deploy\",\n    \"deployerPvtKey\": \"\",\n    \"maxFeePerGas\": \"\",\n    \"maxPriorityFeePerGas\": \"\",\n    \"multiplierGas\": \"\",\n    \"programVKey\": \"0xac51a6a2e513d02e4f39ea51d4d133cec200b940805f1054eabbb6d6412c959f\",\n    \"isVanillaClient\": true,\n    \"sovereignParams\": {\n        \"bridgeManager\": \"0xC7899Ff6A3aC2FF59261bD960A8C880DF06E1041\",\n        \"sovereignWETHAddress\": \"0x0000000000000000000000000000000000000000\",\n        \"sovereignWETHAddressIsNotMintable\": false,\n        \"globalExitRootUpdater\": \"0xB55B27Cca633A73108893985350bc26B8A00C43a\",\n        \"globalExitRootRemover\": \"0xB55B27Cca633A73108893985350bc26B8A00C43a\"\n    },\n    \"aggchainParams\": {\n        \"initParams\": {\n            \"l2BlockTime\": 1,\n            \"rollupConfigHash\": \"0x1111111111111111111111111111111111111111111111111111111111111111\",\n            \"startingOutputRoot\" : \"0x1111111111111111111111111111111111111111111111111111111111111111\",\n            \"startingBlockNumber\": 100,\n            \"startingTimestamp\": 7000000,\n            \"submissionInterval\": 5,\n            \"aggchainManager\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\",\n            \"optimisticModeManager\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\"\n        },\n        \"useDefaultGateway\": true,\n        \"ownedAggchainVKey\": \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\",\n        \"aggchainVKeySelector\": \"0x1234\",\n        \"vKeyManager\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\"\n    }\n}\n</code></pre>"},{"location":"aggregation-layer/v0.3.0/Docker/#222-description","title":"2.2.2. Description","text":"<ul> <li><code>realVerifier</code>: bool, Indicates whether deploy a real verifier or not for the new created</li> <li><code>trustedSequencerURL</code>: string, trustedSequencer URL</li> <li><code>networkName</code>: string, networkName</li> <li><code>description</code>: string, Description of the new rollup type</li> <li><code>trustedSequencer</code>: address, trusted sequencer address</li> <li><code>chainID</code>: uint64, chainID of the new rollup</li> <li><code>adminZkEVM</code>: address, Admin address, can adjust Rollup parameters</li> <li><code>forkID</code>: uint64, Fork ID of the new rollup, indicates the prover (zkROM/executor) version</li> <li><code>consensusContract</code>: select between consensus contract. Supported: <code>[\"PolygonZkEVMEtrog\", \"PolygonValidiumEtrog\", \"PolygonPessimisticConsensus\", \"AggchainECDSA\", \"AggchainFEP\"]</code>.</li> <li><code>gasTokenAddress</code>: address, Gas token address, empty or address(0) for ether</li> <li><code>programVKey</code>:  program key for pessimistic consensus. if consensus != pessimistic, programVKey === bytes32(0).</li> <li><code>isVanillaClient</code>: Flag for vanilla/sovereign clients handling</li> <li><code>sovereignParams</code>: Only mandatory if isVanillaClient = true<ul> <li><code>bridgeManager</code>: bridge manager address</li> <li><code>sovereignWETHAddress</code>: sovereign WETH address</li> <li><code>sovereignWETHAddressIsNotMintable</code>: Flag to indicate if the wrapped ETH is not mintable</li> <li><code>globalExitRootUpdater</code>: Address of globalExitRootUpdater for sovereign chains</li> <li><code>globalExitRootRemover</code>: Address of globalExitRootRemover for sovereign chains</li> </ul> </li> <li><code>aggchainParams</code>: Only mandatory if consensusContract is AggchainECDSA or AggchainFEP<ul> <li><code>initParams</code>: Only mandatory if consensusContract is AggchainFEP<ul> <li><code>l2BlockTime</code>: The time between L2 blocks in seconds</li> <li><code>rollupConfigHash</code>: The hash of the chain's rollup configuration</li> <li><code>startingOutputRoot</code>: Init output root</li> <li><code>startingBlockNumber</code>: The number of the first L2 block</li> <li><code>startingTimestamp</code>:  The timestamp of the first L2 block</li> <li><code>submissionInterval</code>: The minimum interval in L2 blocks at which checkpoints must be submitted</li> <li><code>aggchainManager</code>: Address that manages all the functionalities related to the aggchain</li> <li><code>optimisticModeManager</code>: Address that can trigger the optimistic mode</li> </ul> </li> <li><code>useDefaultGateway</code>: bool, flag to setup initial values for the owned gateway</li> <li><code>ownedAggchainVKey</code>: bytes32, Initial owned aggchain verification key</li> <li><code>aggchainVKeySelector</code>: bytes2, Initial aggchain selector</li> <li><code>vKeyManager</code>: address, Initial vKeyManager</li> </ul> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/Docker/#223-docker-config-file-ecdsa","title":"2.2.3. Docker config file (ECDSA)","text":"<p>This aggchain is not deployed by default. You can deploy it, as we mentioned in the following section, by running the script that deploys a rollup of each type.</p> <pre><code>{\n    \"trustedSequencerURL\": \"http://zkevm-json-rpc:8123\",\n    \"networkName\": \"zkevm\",\n    \"description\": \"0.0.1\",\n    \"trustedSequencer\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\",\n    \"chainID\": 1002,\n    \"adminZkEVM\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\",\n    \"forkID\": 0,\n    \"consensusContract\": \"AggchainECDSA\",\n    \"gasTokenAddress\": \"deploy\",\n    \"deployerPvtKey\": \"\",\n    \"maxFeePerGas\": \"\",\n    \"maxPriorityFeePerGas\": \"\",\n    \"multiplierGas\": \"\",\n    \"programVKey\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n    \"isVanillaClient\": true,\n    \"sovereignParams\": {\n        \"bridgeManager\": \"0xC7899Ff6A3aC2FF59261bD960A8C880DF06E1041\",\n        \"sovereignWETHAddress\": \"0x0000000000000000000000000000000000000000\",\n        \"sovereignWETHAddressIsNotMintable\": false,\n        \"globalExitRootUpdater\": \"0xB55B27Cca633A73108893985350bc26B8A00C43a\",\n        \"globalExitRootRemover\": \"0xB55B27Cca633A73108893985350bc26B8A00C43a\"\n    },\n    \"aggchainParams\": {\n        \"useDefaultGateway\": true,\n        \"initOwnedAggchainVKey\": \"0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890\",\n        \"initAggchainVKeyVersion\": \"0x5678\",\n        \"vKeyManager\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\"\n    }\n}\n</code></pre>"},{"location":"aggregation-layer/v0.3.0/Docker/#223-docker-config-file-ecdsa-v020","title":"2.2.3. Docker config file (ecdsa-v.0.2.0)","text":"<p>This aggchain is not deployed by default. You can deploy it, as we mentioned in the following section, by running the script that deploys a rollup of each type.</p> <pre><code>{\n    \"realVerifier\": false,\n    \"trustedSequencerURL\": \"http://zkevm-json-rpc:8123\",\n    \"networkName\": \"zkevm\",\n    \"description\": \"0.0.1\",\n    \"trustedSequencer\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\",\n    \"chainID\": 1003,\n    \"adminZkEVM\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\",\n    \"forkID\": 11,\n    \"consensusContract\": \"PolygonPessimisticConsensus\",\n    \"gasTokenAddress\": \"0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0\",\n    \"deployerPvtKey\": \"\",\n    \"maxFeePerGas\": \"\",\n    \"maxPriorityFeePerGas\": \"\",\n    \"multiplierGas\": \"\",\n    \"programVKey\": \"0xac51a6a2e513d02e4f39ea51d4d133cec200b940805f1054eabbb6d6412c959f\",\n    \"isVanillaClient\": false,\n    \"sovereignParams\": {\n        \"bridgeManager\": \"0xC7899Ff6A3aC2FF59261bD960A8C880DF06E1041\",\n        \"sovereignWETHAddress\": \"0x0000000000000000000000000000000000000000\",\n        \"sovereignWETHAddressIsNotMintable\": false,\n        \"globalExitRootUpdater\": \"0xB55B27Cca633A73108893985350bc26B8A00C43a\",\n        \"globalExitRootRemover\": \"0xB55B27Cca633A73108893985350bc26B8A00C43a\"\n    }\n}\n</code></pre>"},{"location":"aggregation-layer/v0.3.0/Docker/#23-optional-parameters-on-both-deployments","title":"2.3. Optional Parameters on both deployments","text":"<ul> <li><code>deployerPvtKey</code>: string, pvtKey of the deployer, overrides the address in <code>MNEMONIC</code> of <code>.env</code> if exist</li> <li><code>maxFeePerGas</code>: string, Set <code>maxFeePerGas</code>, must define as well <code>maxPriorityFeePerGas</code> to use it</li> <li><code>maxPriorityFeePerGas</code>: string, Set <code>maxPriorityFeePerGas</code>, must define as well <code>maxFeePerGas</code> to use it</li> <li><code>multiplierGas</code>: number, Gas multiplier with 3 decimals. If <code>maxFeePerGas</code> and <code>maxPriorityFeePerGas</code> are set, this will not take effect</li> <li><code>dataAvailabilityProtocol</code>: string, Data availability protocol, only mandatory/used when consensus contract is a Validium, currently the only supported value is: <code>PolygonDataCommittee</code></li> </ul>"},{"location":"aggregation-layer/v0.3.0/Docker/#3-run-script","title":"3. Run script","text":"<p>In project root execute:</p> <ul> <li> <p>With this command, you can deploy an environment with an <code>AggchainFEP</code>: <pre><code>npm i\nnpm run docker:contracts\n</code></pre></p> </li> <li> <p>With the following command, you achieve the same, but using the new version of <code>docker-compose</code>:</p> </li> </ul> <pre><code>npm i\nnpm run dockerv2:contracts\n</code></pre> <ul> <li>And finally, with this command, you get an environment with <code>AggchainFEP</code>, <code>AggchainECDSA</code>, and <code>PessimisticConsensus</code>, using the new version of <code>docker-compose</code>: <pre><code>npm i \nnpm run dockerv2:contracts:all\n</code></pre></li> </ul> <p>A new docker <code>geth-zkevm-contracts:latest</code> will be created This docker will contain a geth node with the deployed contracts. To run the docker you can use: <code>docker run -p 8545:8545 geth-zkevm-contracts:latest</code>.</p> <p>To create other rollup:</p> <ul> <li>copy template from <code>./docker/scripts/v2/create_rollup_parameters_docker-xxxx.json</code> to <code>deployment/v2/create_rollup_parameters.json</code></li> <li>update <code>chainID</code></li> <li>copy <code>genesis.json</code>, <code>genesis_sovereign.json</code> and <code>deploy_ouput.json</code> (from <code>docker/deploymentOutput</code>) to <code>deployment/v2/</code></li> <li>run <code>npx hardhat run ./deployment/v2/4_createRollup.ts --network localhost</code></li> <li>If you want, you can copy the file that has been generated here (<code>deployment/v2/create_rollup_output_*.json</code>) to deployment output folder (<code>docker/deploymentOutput</code>)</li> </ul>"},{"location":"aggregation-layer/v0.3.0/Docker/#4-deployment-output","title":"4. Deployment output","text":"<p>The deployment output can be found in:</p> <ul> <li><code>docker/deploymentOutput/create_rollup_output.json</code></li> <li><code>docker/deploymentOutput/deploy_output.json</code></li> <li><code>docker/deploymentOutput/genesis.json</code></li> <li><code>docker/deploymentOutput/genesis_sovereign.json</code></li> <li><code>docker/deploymentOutput/aggLayerGateway.json</code></li> </ul>"},{"location":"aggregation-layer/v0.3.0/Docker/#5-diff-with-version-v020","title":"5. Diff with version v0.2.0","text":""},{"location":"aggregation-layer/v0.3.0/Docker/#51-deploy_parametersjson","title":"5.1. deploy_parameters.json","text":"<ul> <li>Add:<ul> <li><code>ppVKey</code>: pessimistic program verification key (AggLayerGateway)</li> <li><code>ppVKeySelector</code>:  The 4 bytes selector to add to the pessimistic verification keys (AggLayerGateway)</li> <li><code>realVerifier</code>: bool, Indicates whether deploy a real verifier or not (AggLayerGateway)</li> </ul> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/Docker/#52-deploy_outputjson","title":"5.2. deploy_output.json","text":"<ul> <li>Add:<ul> <li><code>aggLayerGatewayAddress</code>: AggLayerGateway address</li> <li><code>pessimisticVKeyRouteALGateway</code>: AggLayerGateway information. Pessimistic VKey Route:<ul> <li><code>ppVKey</code>: pessimistic program verification key</li> <li><code>ppVKeySelector</code>: 4 bytes selector to add to the pessimistic verification keys</li> <li><code>verifier</code>: address of the SP1 verifier contract</li> </ul> </li> </ul> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/Docker/#53-create_rollup_parametersjson","title":"5.3. create_rollup_parameters.json","text":"<ul> <li>Add:<ul> <li><code>isVanillaClient</code>: Flag for vanilla/sovereign clients handling</li> <li><code>sovereignParams</code>: Only mandatory if isVanillaClient = true<ul> <li><code>bridgeManager</code>: bridge manager address</li> <li><code>sovereignWETHAddress</code>: sovereign WETH address</li> <li><code>sovereignWETHAddressIsNotMintable</code>: Flag to indicate if the wrapped ETH is not mintable</li> <li><code>globalExitRootUpdater</code>: Address of globalExitRootUpdater for sovereign chains</li> <li><code>globalExitRootRemover</code>: Address of globalExitRootRemover for sovereign chains</li> </ul> </li> <li><code>aggchainParams</code>: Only mandatory if consensusContract is AggchainECDSA or AggchainFEP<ul> <li><code>initParams</code>: Only mandatory if consensusContract is AggchainFEP<ul> <li><code>l2BlockTime</code>: The time between L2 blocks in seconds</li> <li><code>rollupConfigHash</code>: The hash of the chain's rollup configuration</li> <li><code>startingOutputRoot</code>: Init output root</li> <li><code>startingBlockNumber</code>: The number of the first L2 block</li> <li><code>startingTimestamp</code>:  The timestamp of the first L2 block</li> <li><code>submissionInterval</code>: The minimum interval in L2 blocks at which checkpoints must be submitted</li> <li><code>aggchainManager</code>: Address that manages all the functionalities related to the aggchain</li> <li><code>optimisticModeManager</code>: Address that can trigger the optimistic mode</li> </ul> </li> <li><code>useDefaultGateway</code>: bool, flag to setup initial values for the owned gateway</li> <li><code>ownedAggchainVKey</code>: bytes32, Initial owned aggchain verification key</li> <li><code>aggchainVKeySelector</code>: bytes2, Initial aggchain selector</li> <li><code>vKeyManager</code>: address, Initial vKeyManager</li> </ul> </li> </ul> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/Docker/#54-create_rollup_output_","title":"5.4. create_rollup_output_*","text":"<ul> <li>Output from <code>4_createRollup</code> is <code>create_rollup_output_&lt;timestamp&gt;.json</code>.</li> <li>Add <code>defaultAggchainVKeyALGateway</code>, AggLayerGateway information. Default aggchain VKey:<ul> <li><code>defaultAggchainSelector</code>: 4 bytes selector for default aggchain verification key</li> <li><code>newAggchainVKey</code>: default aggchain verification key</li> </ul> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/Docker/#55-deployed-consensus","title":"5.5. Deployed consensus","text":"<p>Previously, a <code>PolygonPessimisticConsensus</code> was deployed. Now, by default, we deploy an <code>AggchainFEP</code>.  </p> <p>If you choose the <code>dockerv2:contracts:all</code> option, all three versions are deployed:</p> <ul> <li><code>AggchainFEP</code></li> <li><code>AggchainECDSA</code></li> <li><code>PolygonPessimisticConsensus</code></li> </ul>"},{"location":"aggregation-layer/v0.3.0/FAQs/","title":"FAQs","text":""},{"location":"aggregation-layer/v0.3.0/FAQs/#1-docker","title":"1. Docker","text":""},{"location":"aggregation-layer/v0.3.0/FAQs/#why-use-sudo-in-docker-scripts","title":"Why use <code>sudo</code> in docker scripts?","text":"<p>The use of sudo with those files is required to ensure compatibility with <code>GHA</code> (GitHub Actions), as elevated permissions are often necessary in that environment. However, in some cases, it may be necessary to remove those commands from the script when running docker locally, depending on the user's system configuration and permissions.</p>"},{"location":"aggregation-layer/v0.3.0/FAQs/#what-about-the-legacy-rollups-pp","title":"What about the legacy rollups (PP)?","text":"<p>You can still create rollups using the same process as before. Compatibility remains unchanged \u2014 we've only added support for the new ones.</p> <p>To better understand compatibility, you can refer to this table.</p> <p>Note that the deployment files have changed slightly, as mentioned in this section.</p>"},{"location":"aggregation-layer/v0.3.0/FAQs/#2-smart-contracts","title":"2. Smart Contracts","text":""},{"location":"aggregation-layer/v0.3.0/FAQs/#contracts-errors-events-and-functions-selectors","title":"Contracts errors, events and functions selectors","text":"<p>This link contains the full list of contract errors (and their signatures), as well as the functions and events.</p>"},{"location":"aggregation-layer/v0.3.0/FAQs/#reverted-with-data-0x","title":"Reverted with data '0x'","text":"<p>Potential cases:</p> <ul> <li> <p>function selector (first 4 bytes on the calldata)</p> </li> <li> <p>calldata parameters defined as <code>bytes</code> incorrectly parsed inside the SC:</p> <ul> <li>bytes proof<ul> <li>must follow this enconding</li> <li>sanity check on the length here</li> <li>parsed in here and here</li> <li>note that if the verifier is mock...everything will be fine. If the verififer is real, SP1 also does some parsing here and here</li> </ul> </li> <li>aggchainData<ul> <li>parsed here and here</li> </ul> </li> </ul> </li> <li>calldata <code>cast</code> parsing: <pre><code>cast decode-calldata \"verifyPessimisticTrustedAggregator(uint32,uint32,bytes32,bytes32,bytes,bytes)\" 0x6c76687700000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000059824c4849da053ff471f1ce2bc4f8fc2d257aa61fc7bee86c1f5ce0463f7d4a68756fe264848d34dd69293eac0fc7ad0c7d0eaf9398231b17b381b13b8af7035400000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000004000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000420000c52de932284856798760c67a6c602cdd0f47ae4af86321e44ed28637f634dbef0000000000000000000000000000000000000000000000000000000000000169000000000000000000000000000000000000000000000000000000000000 | \\\nawk '\n  NR==1 { print \"rollupID: \" $0 }\n  NR==2 { print \"l1InfoTreeLeafCount:   \" $0 }\n  NR==3 { print \"newLocalExitRoot:    \" $0 }\n  NR==4 { print \"newPessimisticRoot:      \" $0 }\n  NR==5 { print \"proof:         \" $0 }\n  NR==6 { print \"aggchainData:  \" $0 }\n'\n</code></pre></li> </ul>"},{"location":"aggregation-layer/v0.3.0/FAQs/#3-vkeys-aggchain-fep","title":"3. VKeys Aggchain (FEP)","text":"VKey Alternative Names Prover Primary Use Used When... Change with <code>programVkey</code> <code>agglayerVkey</code> agglayer Only used for pessimistic <code>addNewRollupType</code> -&gt; PolygonRollupManager create new rollup type <code>pessimisticVkey</code> / <code>ppVkey</code> <code>agglayerVkey</code> agglayer Only used for FEP, v0.3.0 Whenever configuring the <code>aggLayerGateway</code> (deploy_parameters.json) <code>addPessimisticVKeyRoute</code> -&gt; AgglayerGateway <code>aggchainVkey</code> <code>aggkitVkey</code> aggkit-prover Only used for FEP, v0.3.0 During FEP setup: aggchainParams <code>initOwnedAggchainVKey</code> &amp;  <code>addDefaultAggchainVKey</code> --&gt; AgglayerGateway <code>addDefaultAggchainVKey/updateDefaultAggchainVKey</code> -&gt; AgglayerGateway,  <code>addOwnedAggchainVKey</code> -&gt; rollupContract <code>aggregationVkey</code> \u2014 op-succinct-proposer Only used for FEP, v0.3.0 initParams:   aggregationVkey \u2014 <p>During environment setup, four distinct verification keys (vkeys) are defined, each serving a specific purpose in the proof verification and deployment workflows. Below is a detailed description of each key and its corresponding usage:</p>"},{"location":"aggregation-layer/v0.3.0/FAQs/#programvkey","title":"programVkey","text":"<p>This key is used to verify proofs (<code>agglayer-prover</code>) when operating under pessimistic consensus.   In any scenario outside of pessimistic consensus, the value of programVkey must be set to zero (0).</p>"},{"location":"aggregation-layer/v0.3.0/FAQs/#pessimisticvkey-agglayervkey-or-ppvkey","title":"pessimisticVkey (<code>agglayerVkey</code> or <code>ppvkey</code>)","text":"<p>Similar to programVkey, this key is used to verify proofs (<code>agglayer-prover</code>).</p> <p>This is the vkey to be specified in the deploy_parameters.json file when launching a new environment.</p> <p>To add a new ppvkey after deployment, it must be registered in the AgglayerGateway contract using the addPessimisticVKeyRoute function.</p> <p>A dedicated tool is available to facilitate this operation.</p> <p>Cast commands:</p> <ul> <li><code>addPessimisticVKeyRoute</code> <pre><code>cast send \\\n  --rpc-url $SEPOLIA_PROVIDER \\\n  --private-key $ZKEVM_ADMIN_KEY \\\n  $AGGLAYER_GW_ADDR \\\n  'addPessimisticVKeyRoute(bytes4,address,bytes32)' \\\n  $AGGLAYER_VKEYSELECTOR $PPVKEY_VERIFIER $AGGLAYER_VKEY\n</code></pre></li> <li>check <code>pessimisticVKeyRoute</code> <pre><code>cast call \\\n  --rpc-url $SEPOLIA_PROVIDER \\\n  $AGGLAYER_GW_ADDR \\\n  'pessimisticVKeyRoutes(bytes4)' \\\n  $AGGLAYER_VKEYSELECTOR\n</code></pre></li> </ul>"},{"location":"aggregation-layer/v0.3.0/FAQs/#aggchainvkey","title":"aggchainVkey","text":"<p>This key is used by the <code>aggkit-prover</code>.</p> <p>During the initialize step of the FEP, it must be included in aggchainParams under the <code>initOwnedAggchainVKey</code> field.</p> <p>It must be added to the AgglayerGateway using the a <code>addDefaultAggchainVKey</code> tool.</p> <p>To update this vkey after deployment, use either <code>addDefaultAggchainVKey</code> (tool) or <code>updateDefaultAggchainVKey</code> (tool).</p> <p>Additionally, the <code>ownedAggchainVkey</code> field must be updated on the <code>rollupContract</code> with this <code>addOwnedAggchainVKey</code> function or <code>updateOwnedAggchainVKey</code> function.</p> <p>Cast commands:</p> <ul> <li><code>addOwnedAggchainVKey</code> <pre><code>cast send \\\n  --rpc-url $SEPOLIA_PROVIDER \\\n  --private-key $ZKEVM_ADMIN_KEY \\\n  $ROLLUP_ADDR \\\n  'addOwnedAggchainVKey(bytes4,bytes32)' \\\n  $AGGKIT_VKEYSELECTOR $AGGKIT_VKEY\n</code></pre></li> <li><code>updateOwnedAggchainVKey</code> (same <code>AGGKIT_VKEYSELECTOR</code>)   <pre><code>cast send \\\n  --rpc-url $SEPOLIA_PROVIDER \\\n  --private-key $ZKEVM_ADMIN_KEY \\\n  $ROLLUP_ADDR \\\n  'updateOwnedAggchainVKey(bytes4,bytes32)' \\\n  $AGGKIT_VKEYSELECTOR $AGGKIT_VKEY\n</code></pre></li> <li>check <code>ownedAggchainVKey</code> <pre><code>cast call \\\n  --rpc-url $SEPOLIA_PROVIDER \\\n  $ROLLUP_ADDR \\\n  'ownedAggchainVKeys(bytes4)' \\\n  $AGGKIT_VKEYSELECTOR\n</code></pre></li> <li><code>addDefaultAggchainVKey</code> <pre><code>cast send \\\n  --rpc-url $SEPOLIA_PROVIDER \\\n  --private-key $ZKEVM_ADMIN_KEY \\\n  $AGGLAYER_GW_ADDR \\\n  'addDefaultAggchainVKey(bytes4,bytes32)' \\\n  $AGGKIT_VKEYSELECTOR $AGGKIT_VKEY\n</code></pre></li> <li><code>updateDefaultAggchainVKey</code> (same <code>AGGKIT_VKEYSELECTOR</code>)   <pre><code>cast send \\\n  --rpc-url $SEPOLIA_PROVIDER \\\n  --private-key $ZKEVM_ADMIN_KEY \\\n  $AGGLAYER_GW_ADDR \\\n  'updateDefaultAggchainVKey(bytes4,bytes32)' \\\n  $AGGKIT_VKEYSELECTOR $AGGKIT_VKEY\n</code></pre></li> <li>check <code>defaultAggchainVKey</code> <pre><code>cast call \\\n  --rpc-url $SEPOLIA_PROVIDER \\\n  $AGGLAYER_GW_ADDR \\\n  'defaultAggchainVKeys(bytes4)' \\\n  $AGGKIT_VKEYSELECTOR\n</code></pre></li> </ul>"},{"location":"aggregation-layer/v0.3.0/FAQs/#aggregationvkey","title":"aggregationVkey","text":"<p>This vkey is provided by the <code>op-succinct-proposer</code> component.</p>"},{"location":"aggregation-layer/v0.3.0/FAQs/#4-debug-invalid-proof","title":"4. Debug Invalid Proof","text":"<p>When encountering the <code>InvalidProof error</code>, it's important to understand that this means the proof being submitted is not valid\u2014as the error name itself suggests.</p> <p>When we call the <code>verifyPessimisticTrustedAggregator</code> function, we do so with the following parameters: <pre><code>uint32 rollupID,\nuint32 l1InfoTreeLeafCount,\nbytes32 newLocalExitRoot,\nbytes32 newPessimisticRoot,\nbytes calldata proof,\nbytes calldata aggchainData\n</code></pre></p> <p>Internally, this function invokes <code>verifyProof</code>, which is called with three key parameters: - <code>programVKey</code> - <code>publicValues</code> - <code>proofBytes</code></p> <p>These are the required inputs for eventually calling the underlying <code>verify</code> function.</p>"},{"location":"aggregation-layer/v0.3.0/FAQs/#proofbytes","title":"proofBytes","text":"<p>This parameter is typically correct. If you run into a <code>WrongVerifierSelector</code> error instead, it usually means that the verification is being routed to the wrong verifier.</p>"},{"location":"aggregation-layer/v0.3.0/FAQs/#programvkey_1","title":"programVKey","text":"<p>You should ensure that this verification key (vkey) is correct.</p> <ul> <li>For rollups using a verifier of type <code>pessimistic</code>, the key is named <code>programVKey</code>.</li> <li>For rollups using an <code>ALGateway</code> verifier, the key is called <code>pessimisticVKey</code>.</li> </ul> <p>It is crucial to confirm that the vkey you\u2019re using matches the one expected by the system. You can validate this by using the appropriate command for each verifier type:</p> <ul> <li>Command for rollup with <code>pessimistic</code> verifier</li> </ul> <pre><code>cast call &lt;polygonRollupManager&gt; \"rollupIDToRollupDataV2Deserialized(uint32)(address,uint64,address,uint64,bytes32,uint64,uint64,uint64,uint64,uint8,bytes32,bytes32)\" &lt;rollupID&gt; --rpc-url &lt;sepolia_url&gt;\n</code></pre> <p>fill , ,  <p>The <code>programVKey</code> is the last parameter of the output.</p> <ul> <li> <p>Output: </p> <ul> <li>0xF21452f6b9606B4026fd1C057FDbd8bB7E33c487</li> <li>472</li> <li>0x0459d576A6223fEeA177Fb3DF53C9c77BF84C459</li> <li>12</li> <li>0x6a327b365efeb205f2dedc9ec6dd505d3c5c5dbb6d84a33233d4a9d6fb74295c</li> <li>0</li> <li>0</li> <li>0</li> <li>30</li> <li>1</li> <li>0x04970a4ae71b81bfca444f84318475a48475e6d1a1c6126e31c046d952eec6f2</li> <li>0x00eff0b6998df46ec388bb305618089ae3dc74e513e7676b2e1909694f49cc30</li> </ul> </li> <li> <p>Command for rollup with <code>ALGateway</code> verifier</p> </li> </ul> <pre><code>cast call &lt;agglayerGatewayAddress&gt; \"pessimisticVKeyRoutes(bytes4)(address,bytes32,bool)\" &lt;ppSelector&gt; --rpc-url &lt;sepolia_url&gt;\n</code></pre> <p>fill , ,  <p>The <code>pessimisticVkey</code> is the second parameter of the output. - Output:     - 0x0459d576A6223fEeA177Fb3DF53C9c77BF84C459     - 0x00eff0b6998df46ec388bb305618089ae3dc74e513e7676b2e1909694f49cc30     - false</p>"},{"location":"aggregation-layer/v0.3.0/FAQs/#publicinputs","title":"publicInputs","text":"<pre><code>publicInputs = _getInputPessimisticBytes(\n    rollupID,\n    rollup,\n    l1InfoRoot,\n    newLocalExitRoot,\n    newPessimisticRoot,\n    aggchainData\n);\n</code></pre> <p>where:</p> <pre><code>inputPessimisticBytes = abi.encodePacked(\n    rollup.lastLocalExitRoot,\n    rollup.lastPessimisticRoot,\n    l1InfoTreeRoot,\n    rollupID,\n    consensusHash,\n    newLocalExitRoot,\n    newPessimisticRoot\n);\n</code></pre> <p>These are the parameters used to construct the public inputs. Therefore, we should carefully review each one individually to ensure they are correct:</p>"},{"location":"aggregation-layer/v0.3.0/FAQs/#lastlocalexitroot-lastpessimisticroot","title":"lastLocalExitRoot &amp; lastPessimisticRoot","text":"<pre><code>cast call &lt;polygonRollupManager&gt; \"rollupIDToRollupDataV2Deserialized(uint32)(address,uint64,address,uint64,bytes32,uint64,uint64,uint64,uint64,uint8,bytes32,bytes32)\" &lt;rollupID&gt; --rpc-url &lt;sepolia_url&gt;\n</code></pre> <ul> <li>Output: <ul> <li>0xF21452f6b9606B4026fd1C057FDbd8bB7E33c487</li> <li>472</li> <li>0x0459d576A6223fEeA177Fb3DF53C9c77BF84C459</li> <li>12</li> <li>0x6a327b365efeb205f2dedc9ec6dd505d3c5c5dbb6d84a33233d4a9d6fb74295c (<code>lastLocalExitRoot</code>)</li> <li>0</li> <li>0</li> <li>0</li> <li>30</li> <li>1</li> <li>0x04970a4ae71b81bfca444f84318475a48475e6d1a1c6126e31c046d952eec6f2 (<code>lastPessimisticRoot</code>)</li> <li>0x00eff0b6998df46ec388bb305618089ae3dc74e513e7676b2e1909694f49cc30</li> </ul> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/FAQs/#l1infotreeroot","title":"l1InfoTreeRoot","text":"<pre><code>cast call &lt;globalExitRootManager&gt; \"l1InfoRootMap(uint32)\" &lt;l1InfoTreeLeafCount&gt; --rpc-url &lt;sepolia_url&gt;\n</code></pre> <p>fill globalExitRootManager, l1InfoTreeLeafCount, sepolia_url</p>"},{"location":"aggregation-layer/v0.3.0/FAQs/#rollupid","title":"rollupID","text":"<pre><code>cast call &lt;rollupManagerAddress&gt; \"rollupAddressToID(address)\" &lt;rollupAddress&gt; --rpc-url &lt;sepolia_url&gt;\n</code></pre> <p>rollupManagerAddress, rollupAddress, sepolia_url</p>"},{"location":"aggregation-layer/v0.3.0/FAQs/#consensushash","title":"consensusHash","text":"<ul> <li> <p>For pessimistic verifier: <pre><code>cast call &lt;rollupContractAddress&gt; \"getConsensusHash()\" --rpc-url &lt;sepolia_url&gt;\n</code></pre></p> <p>fill &lt;rollupContractAddress,  <li> <p>For ALGateway verifier, aggchainFEP --&gt; <code>getAggchainHash(aggchainData)</code>:</p> </li> <pre><code>cast call &lt;rollupContractAddress&gt; \"getAggchainHash(bytes)\" &lt;aggchainData&gt; --rpc-url &lt;sepolia_url&gt;\n</code></pre> <p>ConsensusHash is: <pre><code>keccak256(\n    abi.encodePacked(\n        CONSENSUS_TYPE,\n        getAggchainVKey(_aggchainVKeySelector),\n        aggchainParams\n    )\n);\n</code></pre></p> <p>Where:</p> <ul> <li> <p><code>CONSENSUS_TYPE</code>: <pre><code>cast call &lt;rollupContractAddress&gt; \"CONSENSUS_TYPE()\" --rpc-url &lt;sepolia_url&gt;\n</code></pre></p> <p>fill rollupContractAddress, sepolia_url</p> </li> <li> <p><code>getAggchainVKey(_aggchainVKeySelector)</code>:</p> <ul> <li><code>aggchainVKeySelector</code> from <code>aggchainData</code>: <pre><code>@param aggchainData custom bytes provided by the chain\n    aggchainData:\n     Field:           | _aggchainVKeySelector | _outputRoot  | _l2BlockNumber |\n     length (bits):   | 32                   | 256          | 256            |\n</code></pre></li> </ul> </li> </ul> <p>Then <code>aggchainVKeySelector</code>: <pre><code>cast call &lt;rollupContractAddress&gt; \"getAggchainVKey(bytes4)\" &lt;aggchainVKeySelector&gt; --rpc-url &lt;sepolia_url&gt;\n</code></pre></p> <p>fill rollupContractAddress, aggchainVKeySelector, sepolia_url</p> <ul> <li> <p>aggchainParams: <pre><code>bytes32 aggchainParams = keccak256(\n    abi.encodePacked(\n        l2Outputs[latestOutputIndex()].outputRoot,\n        _outputRoot,\n        _l2BlockNumber,\n        rollupConfigHash,\n        optimisticMode,\n        trustedSequencer,\n        rangeVkeyCommitment,\n        aggregationVkey\n    )\n);\n</code></pre></p> </li> <li> <p>l2Outputs[latestOutputIndex()].outputRoot --&gt; internal</p> </li> <li> <p><code>outputRoot</code>, <code>l2BlockNumber</code> from <code>aggchainData</code>:</p> </li> </ul> <pre><code>@param aggchainData custom bytes provided by the chain\n    aggchainData:\n     Field:           | _aggchainVKeySelector | _outputRoot  | _l2BlockNumber |\n     length (bits):   | 32                    | 256          | 256            |\n</code></pre> <ul> <li> <p>rollupConfigHash: <pre><code>cast call &lt;rollupContractAddress&gt; \"rollupConfigHash()\" --rpc-url &lt;sepolia_url&gt;\n</code></pre></p> </li> <li> <p>optimisticMode: <pre><code>cast call &lt;rollupContractAddress&gt; \"optimisticMode()\" --rpc-url &lt;sepolia_url&gt; \n</code></pre></p> </li> <li> <p>trustedSequencer: <pre><code>cast call &lt;rollupContractAddress&gt; \"trustedSequencer()\" --rpc-url &lt;sepolia_url&gt; \n</code></pre></p> </li> <li> <p>rangeVkeyCommitment: <pre><code>cast call &lt;rollupContractAddress&gt; \"rangeVkeyCommitment()\" --rpc-url &lt;sepolia_url&gt;    \n</code></pre></p> </li> <li> <p>aggregationVkey: <pre><code>cast call &lt;rollupContractAddress&gt; \"aggregationVkey()\" --rpc-url &lt;sepolia_url&gt;    \n</code></pre></p> </li> </ul> <p>fill rollupContractAddress, sepolia_url</p>"},{"location":"aggregation-layer/v0.3.0/FAQs/#newlocalexitroot-newpessimisticroot","title":"newLocalExitRoot &amp; newPessimisticRoot","text":"<ul> <li><code>newLocalExitRoot</code>: New local exit root</li> <li><code>newPessimisticRoot</code>: New pessimistic information, Hash(localBalanceTreeRoot, nullifierTreeRoot)</li> </ul>"},{"location":"aggregation-layer/v0.3.0/FAQs/#quick-command","title":"Quick command","text":""},{"location":"aggregation-layer/v0.3.0/FAQs/#pessimistic","title":"Pessimistic","text":"<pre><code>// TODO: Update params\nPOLYGON_ROLLUP_MANAGER=\"0x..\"\nROLLUP_ADDRESS=\"0x..\"\nGLOBAL_EXIT_ROOT_MANAGER=\"0x..\"\nSEPOLIA_URL=\"https://sepolia...\"\nROLLUP_ID=35\nL1_INFO_TREE_LEAF_COUNT=1\n\noutput=$(cast call $POLYGON_ROLLUP_MANAGER \"rollupIDToRollupDataV2Deserialized(uint32)(address,uint64,address,uint64,bytes32,uint64,uint64,uint64,uint64,uint8,bytes32,bytes32)\" $ROLLUP_ID --rpc-url $SEPOLIA_URL)\nprogramVKey=$(echo \"$output\" | grep -Eo '0x[a-fA-F0-9]{40,}' | tail -n 1)\nlastLocalExitRoot=$(echo \"$output\" | sed -n '5p')\nlastPessimisticRoot=$(echo \"$output\" | tail -n 2 | head -n 1)\nl1InfoTreeRoot=$(cast call $GLOBAL_EXIT_ROOT_MANAGER \"l1InfoRootMap(uint32)\" $L1_INFO_TREE_LEAF_COUNT --rpc-url $SEPOLIA_URL)\nrollupID=$(cast call $POLYGON_ROLLUP_MANAGER \"rollupAddressToID(address)\" $ROLLUP_ADDRESS --rpc-url $SEPOLIA_URL)\nconsensusHash=$(cast call $ROLLUP_ADDRESS \"getConsensusHash()\" --rpc-url $SEPOLIA_URL)\n\necho \"programVKey: $programVKey\"\necho \"lastLocalExitRoot: $lastLocalExitRoot\"\necho \"lastPessimisticRoot: $lastPessimisticRoot\"\necho \"l1InfoTreeRoot: $l1InfoTreeRoot\"\necho \"rollupID (address to ID): $rollupID\"\necho \"consensusHash: $consensusHash\"\n</code></pre>"},{"location":"aggregation-layer/v0.3.0/FAQs/#agglayergateway","title":"AgglayerGateway","text":"<pre><code>// TODO: Update params\nPOLYGON_ROLLUP_MANAGER=\"0x...\"\nROLLUP_ADDRESS=\"0x...\"\nAGGLAYERGATEWAY=\"0x...\"\nGLOBAL_EXIT_ROOT_MANAGER=\"0x...\"\nSEPOLIA_URL=\"https://sepolia...\"\n\nROLLUP_ID=34\nPP_SELECTOR=\"0x00000004\"\nL1_INFO_TREE_LEAF_COUNT=1\nAGGCHAIN_DATA=\"0x...\"\n\noutput=$(cast call $AGGLAYERGATEWAY \"pessimisticVKeyRoutes(bytes4)(address,bytes32,bool)\" $PP_SELECTOR --rpc-url $SEPOLIA_URL)\nprogramVKey=$(echo \"$output\" | sed -n '2p')\noutput=$(cast call $POLYGON_ROLLUP_MANAGER \"rollupIDToRollupDataV2Deserialized(uint32)(address,uint64,address,uint64,bytes32,uint64,uint64,uint64,uint64,uint8,bytes32,bytes32)\" $ROLLUP_ID --rpc-url $SEPOLIA_URL)\nlastLocalExitRoot=$(echo \"$output\" | sed -n '5p')\nlastPessimisticRoot=$(echo \"$output\" | tail -n 2 | head -n 1)\nl1InfoTreeRoot=$(cast call $GLOBAL_EXIT_ROOT_MANAGER \"l1InfoRootMap(uint32)\" $L1_INFO_TREE_LEAF_COUNT --rpc-url $SEPOLIA_URL)\nrollupID=$(cast call $POLYGON_ROLLUP_MANAGER \"rollupAddressToID(address)\" $ROLLUP_ADDRESS --rpc-url $SEPOLIA_URL)\nconsensusHash=$(cast call $ROLLUP_ADDRESS \"getAggchainHash(bytes)\" $AGGCHAIN_DATA --rpc-url $SEPOLIA_URL)\nrollupConfigHash=$(cast call $ROLLUP_ADDRESS \"rollupConfigHash()\" --rpc-url $SEPOLIA_URL)\noptimisticMode=$(cast call $ROLLUP_ADDRESS \"optimisticMode()\" --rpc-url $SEPOLIA_URL)\ntrustedSequencer=$(cast call $ROLLUP_ADDRESS \"trustedSequencer()\" --rpc-url $SEPOLIA_URL)\nrangeVkeyCommitment=$(cast call $ROLLUP_ADDRESS \"rangeVkeyCommitment()\" --rpc-url $SEPOLIA_URL)\naggregationVkey=$(cast call $ROLLUP_ADDRESS \"aggregationVkey()\" --rpc-url $SEPOLIA_URL)\n\necho \"programVKey: $programVKey\"\necho \"lastLocalExitRoot: $lastLocalExitRoot\"\necho \"lastPessimisticRoot: $lastPessimisticRoot\"\necho \"l1InfoTreeRoot: $l1InfoTreeRoot\"\necho \"rollupID (address to ID): $rollupID\"\necho \"consensusHash: $consensusHash\"\necho \"rollupConfigHash: $rollupConfigHash\"\necho \"optimisticMode: $optimisticMode\"\necho \"trustedSequencer: $trustedSequencer\"\necho \"rangeVkeyCommitment: $rangeVkeyCommitment\"\necho \"aggregationVkey: $aggregationVkey\"\n</code></pre>"},{"location":"aggregation-layer/v0.3.0/Roles/","title":"Roles","text":"<p>Table with all roles that are new to this release and should be properly assigned</p>"},{"location":"aggregation-layer/v0.3.0/Roles/#agglayer-protocol","title":"AggLayer protocol","text":"Contract Role/Address ALGateway <code>DEFAULT_ADMIN_ROLE</code> ALGateway <code>AGGCHAIN_DEFAULT_VKEY_ROLE</code> ALGateway <code>AL_ADD_PP_ROUTE_ROLE</code> ALGateway <code>AL_FREEZE_PP_ROUTE_ROLE</code>"},{"location":"aggregation-layer/v0.3.0/Roles/#recommendation","title":"Recommendation","text":"<ul> <li><code>DEFAULT_ADMIN_ROLE</code>: current timelock deployed</li> <li><code>AGGCHAIN_DEFAULT_VKEY_ROLE</code>: current multisig, security assumptions for aggchainDefaultVKeyRoleAddress are the same as for updating a rollup which currently is brought by a multisig.</li> <li><code>AL_ADD_PP_ROUTE_ROLE</code>: current timelock deployed</li> <li><code>AL_FREEZE_PP_ROUTE_ROLE</code>: current multisig</li> </ul>"},{"location":"aggregation-layer/v0.3.0/Roles/#katana-l1-fep-aggchain","title":"Katana - L1 (FEP aggchain)","text":"Contract Role FEP vKeyManager FEP admin FEP trustedSequencer FEP aggchainManager FEP optimisticModeManager"},{"location":"aggregation-layer/v0.3.0/Roles/#recommendation_1","title":"Recommendation","text":"<ul> <li><code>vKeyManager</code>: current timelock deployed (most probably not used since it will rely on default aggchain vKeys provided by the ALGateway)</li> <li><code>admin</code>: new Multisig address</li> <li><code>trustedSequencer</code>: new EOA address</li> <li><code>aggchainManager</code>: new internal multisig</li> <li><code>optimisticModeManager</code>: new security council multisig</li> </ul>"},{"location":"aggregation-layer/v0.3.0/Roles/#katana-l2","title":"Katana - L2","text":"Contract Role BridgeL2SovereignChain bridgeManager GlobalExitRootManagerL2SovereignChain globalExitRootUpdater GlobalExitRootManagerL2SovereignChain globalExitRootRemover <ul> <li><code>bridgeManager</code>: new timelock or multisig</li> <li><code>globalExitRootUpdater</code>: EOA (hot wallet <code>aggOracle</code> component)</li> <li><code>globalExitRootRemover</code>: Multisig (security council)</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/","title":"SC Specifications","text":"<ul> <li>SC Specifications<ul> <li>1. Overview<ul> <li>1.1. Glossary</li> <li>1.2. Resources</li> <li>1.3. Requirements</li> <li>1.4. ChangeLog</li> <li>1.5. Breaking changes</li> <li>1.6. Table agglayer chains supported<ul> <li>Migration paths supported</li> </ul> </li> </ul> </li> <li>2. AggLayer Gateway Specifications<ul> <li>2.1. Description</li> <li>2.2. Pessimistic proof routes</li> <li>2.3. Defaut aggchain verification key</li> <li>2.4. AggLayerGateway Access control (roles)<ul> <li>DEFAULT_ADMIN_ROLE</li> <li>AL_ADD_PP_ROUTE_ROLE</li> <li>AL_FREEZE_PP_ROUTE_ROLE</li> <li>AGGCHAIN_DEFAULT_VKEY_ROLE</li> </ul> </li> </ul> </li> <li>3. Generic aggchains specification<ul> <li>3.1. Description</li> <li>3.2. Aggchain interface</li> </ul> </li> <li>4. Aggchain Base implementation<ul> <li>4.1. Flag default vKey</li> <li>4.2. Managing aggchain verification keys</li> <li>4.3. Roles<ul> <li>vKeyManager</li> <li>admin</li> </ul> </li> </ul> </li> <li>5. AggChain Types provided<ul> <li>5.1. ECDSA<ul> <li>5.1.1 Roles<ul> <li>vKeyManager</li> <li>admin</li> <li>trustedSequencer</li> </ul> </li> <li>5.1.2 Test-vectors</li> </ul> </li> <li>5.2. FEP<ul> <li>5.2.1 Roles<ul> <li>vKeyManager</li> <li>admin</li> <li>trustedSequencer</li> <li>aggchainManager</li> <li>optimisticModeManager</li> </ul> </li> <li>5.2.2 Test-vectors</li> </ul> </li> </ul> </li> <li>6. Rollup Manager Specification<ul> <li>6.1. Versioning</li> <li>6.2. AggLayerGateway contract</li> <li>6.3. New VerifierType</li> <li>6.4. Create new chain</li> <li>6.5. Verify pessimitic proof</li> <li>6.6. Pretty rollupData</li> </ul> </li> <li>7. Sovereign SCs updates<ul> <li>7.1 GlobalExitRootManagerL2SovereignChain<ul> <li>7.1.1 insertedGERHashChain &amp; removedGERHashChain</li> </ul> </li> <li>7.2 BridgeL2SovereignChain</li> <li>7.2.1 Unused bits on globalIndex are set to 0</li> <li>7.2.2 LocalBalanceTree<ul> <li>7.2.3 activateEmergencyState &amp; deactivateEmergencyState</li> <li>7.2.4 claimedGlobalIndexHashChain &amp; unsetGlobalIndexHashChain</li> </ul> </li> </ul> </li> <li>8. Roles sovereignChains contracts<ul> <li>8.1. BridgeL2SovereignChain<ul> <li>bridgeManager</li> </ul> </li> <li>8.2. GlobalExitRootManagerL2SovereignChain<ul> <li>globalExitRootUpdater</li> <li>globalExitRootUpdater</li> </ul> </li> </ul> </li> </ul> </li> <li>Smart contracts version updates<ul> <li>Open zeppelin<ul> <li>Updated openzeppelin/contracts@5.0.0 to openzeppelin/contracts@5.2.0</li> <li>Update pragma version 0.8.20 to 0.8.28</li> </ul> </li> </ul> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#1-overview","title":"1. Overview","text":"<p>AggLayer v0.3.0 adds the support for any chain to specify its own requirements. It is up to chain to specify what it does as long as it follows a generic interface provided by the agglayer. Therefore, the agglayer will become agnostic to the chain requirements (EVM, non-EVM, DA source, consensus, ...). That means that any chain can be connected to the aggLayer regardless its execution and consensus layer. Current version only supports EVM chains though. Smart contracts will be adapted to support generic chains that will be attached to the aggLayer. A generic interface will be provided so any chain can do its own logic that could be attached to the aggLayer.</p> <p>In this first phase, aggLayer will provide two default chain types to be selected: ECDSA signature &amp; FEP (full execution proof). Smart contract will let choose between one of those. Long term goal is to fully open chain registration as lomng as the chain fulfills folows a generic interface.</p>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#11-glossary","title":"1.1. Glossary","text":"<ul> <li><code>aggchain</code>: chain connected to the agglayer<ul> <li>all definition related to aggchains can be found on this specification</li> </ul> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#12-resources","title":"1.2. Resources","text":"<ul> <li>Specification Pessimistic circuit v0.3.0</li> <li>Specification aggchain ECDSA</li> <li>Specification aggchain FEP</li> <li>Implementation decisions and iterations on the SC specifications</li> <li>SC implementations</li> <li>Test-vectors</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#13-requirements","title":"1.3. Requirements","text":"<ul> <li>PolygonRollupManager to support generic chains</li> <li>Pessimistic program will only have one version running</li> <li>Pessimistic program updates to be released on all chains at the same time</li> <li>Pessimistic program updates managed by aggLayer</li> <li>Each chain to freely choose its program management. Two options are given:<ul> <li><code>default</code>: management provided by the aggLayer</li> <li><code>custom</code>: own management</li> </ul> </li> <li>Generic interface to allow any chain to specify its own logic</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#14-changelog","title":"1.4. ChangeLog","text":"<p>https://github.com/agglayer/agglayer-contracts/compare/v9.0.0...v10.0.0-rc.8</p>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#15-breaking-changes","title":"1.5. Breaking changes","text":"<ul> <li>Function to create new rollups has been renamed to attachChainToAL<ul> <li>old chains (zkEVM/Validiums/pp-v0.2.0) will need to encode its initialize data. Util function available here</li> </ul> </li> <li>Event addExistingRollup signature has been changed since a new parameter <code>initPessimisticRoot</code> ha sbeen added</li> <li>New functions to properly see therscan rollup data has been added</li> <li>Function verifyPessimisticProof signature has been changed. Added <code>customChainData</code> for aggchains v0.3.0</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#16-table-agglayer-chains-supported","title":"1.6. Table agglayer chains supported","text":"Chain verifierType SC consensus Proofs/Prover Client zkEVM StateTransition PolygonZkEVMEtrog FEP # Hermez cdk-erigon Valididum StateTransition PolygonValidiumEtrog FEP # Hermez cdk-erigon v0.2.0-ECDSA Pessimistic PolygonPessimisticConsensus PP # SP1 cdk-erigon OR op-stack v0.3.0-ECDSA ALGateway AggchainECDSA PP # SP1 not supported (aggkit not built) v0.3.0-FEP ALGateway AggchainFEP (PP + FEP) # SP1 op-stack"},{"location":"aggregation-layer/v0.3.0/SC-specs/#migration-paths-supported","title":"Migration paths supported","text":"<ul> <li>From <code>v0.2.0-ECDSA</code> to <code>v0.3.0-FEP</code></li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#2-agglayer-gateway-specifications","title":"2. AggLayer Gateway Specifications","text":""},{"location":"aggregation-layer/v0.3.0/SC-specs/#21-description","title":"2.1. Description","text":"<p>This smart contract aims to route all proofs posted by the aggLayer (from chains that uses the pessimistic program). Since the <code>AggLayer Gateway</code> contains the pessimistic program verificaton key, all chains that uses the <code>AggLayer Gateway</code> will be upgraded to use its latest version at the same time. This effectively means that a new version on the pessimistic program will NOT require a new rollupType.</p> <p>It will also provide the management of:</p> <ul> <li>pessimistic proof routing (pessimistic program vKeys)</li> <li>default aggchain vkeys</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#22-pessimistic-proof-routes","title":"2.2. Pessimistic proof routes","text":"<p>The pessimistic proof route is defined as follows: <pre><code>struct AggLayerVerifierRoute {\n    address verifier;\n    bytes32 pessimisticVKey;\n    bool frozen;\n}\n</code></pre></p> <p>where:</p> <ul> <li><code>verifier</code>: SP1 verifier address</li> <li><code>pessimisticVKey</code>: pessimistic program verification key</li> <li><code>frozen</code>: a route cannot be longer used</li> </ul> <p>The aggLayer will have 4 bytes embedded in the proof to select the route.</p> <pre><code>mapping(bytes4 pessimisticVKeySelector =&gt; AggLayerVerifierRoute) public pessimisticVKeyRoutes;\n</code></pre> <p>The proof will look like: <pre><code>[  ppSelector  |  SP1 proof ]\n[ 4 bytes      |  X bytes   ]\n</code></pre></p> <p>where <code>SP1 proof</code> is: <pre><code>[           SP1 proof          ]\n[  SP1Selector  |  PLONK proof ]\n[   4 bytes     |    Y bytes   ]\n</code></pre></p> <p>This approach allows to:</p> <ul> <li>aggLayer to select which route to use via the <code>ppSelector</code></li> <li>have multiple version of the pessimistic program or just have one single valid route</li> <li>smooth routing upgrade by not forcing the SC upgrade to be synched with the component upgrade (aggLayer-node)<ul> <li>the new route version could be settled in advance</li> </ul> </li> <li>quickly freeze a route if any critical issue is found on the pessimistic program or the SP1 Verifier</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#23-defaut-aggchain-verification-key","title":"2.3. Defaut aggchain verification key","text":"<p>The default <code>aggchain_vkey</code> is defined as follows: <pre><code>mapping(bytes4 defaultAggchainSelector =&gt; bytes32 defaultAggchainVKey) public defaultAggchainVKeys;\n</code></pre></p> <p>The aggLayer will just add new default <code>aggchain_vkey</code> routed by a 4 bytes selector, the <code>defaultAggchainSelector</code>. The aggLayer can add new versions of a default <code>aggchain_vkey</code> or update them.</p> <p>This approach allows to:</p> <ul> <li>have multiple versions of the default <code>aggchain_vkey</code> or just have one (only updates)</li> <li>single SC transaction to upgrade all the chains that uses the default <code>aggchain_vkey</code></li> <li>no action needed from chains on L1 to use a new default <code>aggchain_vkey</code><ul> <li>probably run the proper component version</li> </ul> </li> <li>if any issue is found on the default <code>aggchain_vkey</code>, it can be overwritten with the right one</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#24-agglayergateway-access-control-roles","title":"2.4. AggLayerGateway Access control (roles)","text":"Role Description DEFAULT_ADMIN_ROLE Grant/Revoke roles AGGLAYER_ADD_ROUTE_ROLE Add PP key AGGLAYER_FREEZE_ROUTE_ROLE Freeze PP key AGGCHAIN_DEFAULT_VKEY_ROLE Add/Update default key"},{"location":"aggregation-layer/v0.3.0/SC-specs/#default_admin_role","title":"DEFAULT_ADMIN_ROLE","text":"<ul> <li>Functionality: Grants and revokes all roles in the contract.</li> <li>Security Assumptions: This role has complete control over the contract\u2019s permissions, making it the most privileged and critical role.</li> <li>Recommended Account Type: Should be a timelock</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#al_add_pp_route_role","title":"AL_ADD_PP_ROUTE_ROLE","text":"<ul> <li>Functionality: Allows adding new pessimistic proof verification key.</li> <li>Security Assumptions: Incorrect key additions can enable invalid proofs, leading to security risks. A malicious pessimistic key can compromise the bridge funds</li> <li>Recommended Account Type: Timelock</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#al_freeze_pp_route_role","title":"AL_FREEZE_PP_ROUTE_ROLE","text":"<ul> <li>Functionality: Freezes existing PP keys, preventing further usage.</li> <li>Security Assumptions: On one hand, if a PP key is behaving wrongly, this role is critical for freezing it quickly to mitigate risks. On the other hand, it can perform a DDOS freezing all keys.</li> <li>Recommended Account Type: Externally Owned Account (EOA) or Multisig. A Multisig is preferred for security, but an EOA with high availability (i.e., always online) might be necessary for quick emergency response.</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#aggchain_default_vkey_role","title":"AGGCHAIN_DEFAULT_VKEY_ROLE","text":"<ul> <li>Functionality: Manages default aggregation keys, allowing updates to default verification keys.</li> <li>Security Assumptions: Incorrect key additions can enable invalid proofs, leading to security risks. A malicious verification key can compromise the funds of a chain.</li> <li>Recommended Account Type: Timelock or multisig, a chain can choose to handle their own keys at any time. Security assumptions for aggchainDefaultVKeyRoleAddress are the same as for updating a rollup which currently is brought by a multisig.</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#3-generic-aggchains-specification","title":"3. Generic aggchains specification","text":""},{"location":"aggregation-layer/v0.3.0/SC-specs/#31-description","title":"3.1. Description","text":"<p>The following specification aims to provide a generic interface that any aggchain must follow in order to be attached to the aggLayer. Each aggchain would need to interact with the RollupManager smart contract on different stages. Those interactions are needed to accomplish an specific interface. Besides the interface, a base implementation will be provided to aggchains in order to have a base code to build from. Note that this base code is recommended to be followed by aggchains but not mandatory.</p>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#32-aggchain-interface","title":"3.2. Aggchain interface","text":"<p>An aggchain smart contract must interact with the rollup manager in the following manner:</p> <ul> <li>Initialization:<ul> <li>interface   <pre><code>function initAggchainManager(address newAggchainManager) external;;\n</code></pre></li> <li>when the aggchain is created, the aggchain must provide its own initialization bytes.</li> </ul> </li> <li>Proof is being verified and RollupManager contract calls aggchain contract to get its <code>aggchain_hash</code>: <pre><code>  /**\n   * @notice Gets aggchain hash.\n   * @dev Each chain should properly manage its own aggchain hash.\n   * @param aggchainData agg chain data to build the consensus hash.\n   */\n  function getAggchainHash(bytes calldata aggchainData) external view returns (bytes32);\n</code></pre></li> <li>Proof is verified and there is callback to the aggchain contract to handle the final chain settlement:   <pre><code>/**\n * @notice Callback from the PolygonRollupManager to update the chain's state.\n * @dev Each chain should properly manage its own state.\n * @param data Custom chain data to update chain's state\n */\nfunction onVerifyPessimistic(bytes calldata aggchainData) external;\n</code></pre></li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#4-aggchain-base-implementation","title":"4. Aggchain Base implementation","text":"<p>It is provided a base implementation of the aggchain in order to serve as a template for any aggchains that want to build its own implementation. In order to maintain storage layout compatibility with previous <code>verifierType version: Pessimistic</code>, the old <code>PolygonConsensusBase</code> is inherited. This design will allow previous chains (v0.2.0) to be upgraded to a new version (v0.3.0) mainting the storage layout and avoiding any error overwriting storage slots. There are two key features on top of the <code>PolygonConsensusBase</code>:</p> <ul> <li>Flag to determine if the default vkeys are used (provided by the <code>ALGateway</code> smart contract)</li> <li>aggchain vkey management functionalities</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#41-flag-default-vkey","title":"4.1. Flag default vKey","text":"<pre><code>// Flag to enable/disable the use of the custom chain gateway to handle the aggchain keys. In case  of true (default), the keys are managed by the aggregation layer gateway\nbool public useDefaultGateway;\n</code></pre>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#42-managing-aggchain-verification-keys","title":"4.2. Managing aggchain verification keys","text":"<p>The chain will be able to select its verification key through a selector, the <code>aggchainVKeySelector</code>. It works very similar as the <code>ppSelector</code>, but instead of selecting the pessimistic verification key, it selects the aggchain verification key</p> <p>The aggchain base code will store all the routed into a mapping: <pre><code>// AggchainVKeyRoutes mapping\nmapping(bytes4 aggchainVKeySelector =&gt; bytes32 ownedAggchainVKey) public ownedAggchainVKeys;\n</code></pre></p> <p>This approach allows to:</p> <ul> <li>have multiple versions of the <code>aggchain_vkey</code> or just have one</li> <li>smooth routing upgrade by not forcing the SC action to be synched with the component upgrade<ul> <li>the new route version could be settled in advance</li> <li>componenet will select which one to use</li> </ul> </li> <li>if any issue is found on the <code>aggchain_vkey</code>, it can be overwritten with the right one</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#43-roles","title":"4.3. Roles","text":""},{"location":"aggregation-layer/v0.3.0/SC-specs/#vkeymanager","title":"vKeyManager","text":"<ul> <li>Functionality: Manages aggchain verification keys, insertions and updates. It can also enable/disable the usage of the default aggchain vkeys (managed by the ALGateway contract)</li> <li>Security Assumptions: A malicious verification key can compromise the funds of a chain (not the entire agglayer)</li> <li>Recommended Account Type: Timelock (specified by the chain itself)</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#admin","title":"admin","text":"<ul> <li>Functionality: Allow to set the <code>trustedSequencer</code> and can manage aggchain upgrades with certain limitations:<ul> <li>cannot update to old <code>rollupTypeID</code></li> <li>cannot update to a different <code>rollupVerifierType</code></li> </ul> </li> <li>Security Assumptions: <code>trustedSequencer</code> usage depends on aggchaintype. Please refer to each aggchain for more details. Upgrades does not imply high security assumptions since it is capped to existing <code>rollupTypes</code></li> <li>Recommended Account Type: Multisig</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#5-aggchain-types-provided","title":"5. AggChain Types provided","text":"<p>Two default aggchain types will be provided to choose from:</p> <ul> <li>ECDSA</li> <li>FEP</li> </ul> <p>Each aggchain provided is identified by 2 bytes: <pre><code>// ECDSA\nbytes2 constant AGGCHAIN_TYPE = 0\n// FEP\nbytes2 constant AGGCHAIN_TYPE = 1\n</code></pre></p> <p>These 2 bytes are used to build the <code>aggchainVKeySelector</code> in case the chain opts for using the <code>defaultAggchainVKey</code>. This has been done to enforce chains to not being able to select which type of aggchain they are. Smart contrct will force those 2 bytes so the default <code>defaultAggchainSelector</code> could be specified as:</p> <pre><code>[         aggchainVKeySelector          ]\n[ aggchainVKeyVersion  |  AGGCHAIN_TYPE ]\n[       2 bytes        |    2 bytes     ]\n</code></pre>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#51-ecdsa","title":"5.1. ECDSA","text":"<ul> <li> <p>NEW AGGCHAIN: custom initialization bytes <pre><code>// custom parsing of the initializeBytesAggchain\n(\n    // aggchainBase params\n    bool _useDefaultGateway,\n    bytes32 _initOwnedAggchainVKey,\n    bytes4 _initAggchainVKeySelector,\n    address _vKeyManager,\n    // PolygonConsensusBase params\n    address _admin,\n    address _trustedSequencer,\n    address _gasTokenAddress,\n    string memory _trustedSequencerURL,\n    string memory _networkName\n) = abi.decode(\n        initializeBytesAggchain,\n        (\n            bool,\n            bytes32,\n            bytes4,\n            address,\n            address,\n            address,\n            address,\n            string,\n            string\n        )\n    );\n</code></pre></p> </li> <li> <p>EXISTING v0.2.0 AGGCHAIN: custom initialization bytes <pre><code>// Only need to initialize values that are specific for ECDSA because we are performing an upgrade from a Pessimistic chain\n// aggchainBase params\n(\n    bool _useDefaultGateway,\n    bytes32 _initOwnedAggchainVKey,\n    bytes2 _initAggchainVKeySelector,\n    address _vKeyManager\n) = abi.decode(\n    initializeBytesAggchain,\n    (bool, bytes32, bytes4, address)\n);\n</code></pre></p> </li> <li> <p>bytes when calling <code>getAggchainHash</code> &amp; <code>onVerifyPessimistic</code>: <pre><code>(\n    bytes2 aggchainVKeySelector,\n    bytes newstateRoot ) = abi.decode(\n        aggchainData,\n        (bytes4, bytes32)\n);\n</code></pre></p> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#511-roles","title":"5.1.1 Roles","text":"Role Description vKeyManager manages aggchain vkeys admin upgrade rollupTypes &amp; set trsutedSequencer trustedSequencer signs PP state transition"},{"location":"aggregation-layer/v0.3.0/SC-specs/#vkeymanager_1","title":"vKeyManager","text":"<ul> <li>Functionality: Manages aggchain verification keys, insertions and updates. It can also enable/disable the usage of the default aggchain vkeys (managed by the ALGateway contract)</li> <li>Security Assumptions: A malicious verification key can compromise the funds of a chain (not the entire agglayer)</li> <li>Recommended Account Type: Timelock (specified by the chain itself)</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#admin_1","title":"admin","text":"<ul> <li>Functionality: Allow to set the <code>trustedSequencer</code> and can manage aggchain upgrades with certain limitations:<ul> <li>cannot update to old <code>rollupTypeID</code></li> <li>cannot update to a different <code>rollupVerifierType</code></li> </ul> </li> <li>Security Assumptions: <code>trustedSequencer</code> sign the chain pp-state-stransistion. It imply high security risk</li> <li>Recommended Account Type: Timelock</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#trustedsequencer","title":"trustedSequencer","text":"<ul> <li>Functionality: Signs chain pp-state-transistion</li> <li>Security Assumptions: Incorrect state-stransistion can lead to steal funds in the chain.</li> <li>Recommended Account Type: EOA or internal multisig</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#512-test-vectors","title":"5.1.2 Test-vectors","text":"<ul> <li>aggchain-data</li> <li>aggchain-init-bytes-v0</li> <li>aggchain-init-bytes-v1</li> <li>hash-aggchain-params</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#52-fep","title":"5.2. FEP","text":"<p>There are two scenarios to be considered in the <code>FEP</code>: new one and one that comes from <code>v0.2.0</code>. The only difference is that all chains coming from <code>v0.2.0</code> that are going to move to a <code>FEP-v0.3.0</code> doe snot need to initialize all their parameters since some of them were initialized before.</p> <ul> <li> <p>NEW AGGCHAIN: custom initialization bytes <pre><code>/// @notice Parameters to initialize the AggchainFEP contract.\nstruct InitParams {\n    uint256 l2BlockTime;\n    bytes32 rollupConfigHash;\n    bytes32 startingOutputRoot;\n    uint256 startingBlockNumber;\n    uint256 startingTimestamp;\n    uint256 submissionInterval;\n    address optimisticModeManager;\n    bytes32 aggregationVkey;\n    bytes32 rangeVkeyCommitment;\n}\n\n// Decode the struct\n(\n    // chain custom params\n    InitParams memory _initParams,\n    // aggchainBase params\n    bool _useDefaultGateway,\n    bytes32 _initOwnedAggchainVKey,\n    bytes4 _initAggchainVKeySelector,\n    address _vKeyManager,\n    // PolygonConsensusBase params\n    address _admin,\n    address _trustedSequencer,\n    address _gasTokenAddress,\n    string memory _trustedSequencerURL,\n    string memory _networkName\n) = abi.decode(\n        initializeBytesAggchain,\n        (\n            InitParams,\n            bool,\n            bytes32,\n            bytes4,\n            address,\n            address,\n            address,\n            address,\n            string,\n            string\n        )\n    );\n\n// init FEP params\n_initializeAggchain(_initParams);\n\n// Set aggchainBase variables\n_initializeAggchainBaseAndConsensusBase(\n    _admin,\n    _trustedSequencer,\n    _gasTokenAddress,\n    _trustedSequencerURL,\n    _networkName,\n    _useDefaultGateway,\n    _initOwnedAggchainVKey,\n    _initAggchainVKeyVersion,\n    _vKeyManager\n);\n</code></pre></p> </li> <li> <p>EXISTING v0.2.0 AGGCHAIN: custom initialization bytes <pre><code>// contract has been previously initialized with all parameters in the PolygonConsensusBase.sol\n// Only initialize the FEP and AggchainBase params\n(\n    // chain custom params\n    InitParams memory _initParams,\n    // aggchainBase params\n    bool _useDefaultGateway,\n    bytes32 _initOwnedAggchainVKey,\n    bytes4 _initAggchainVKeySelector,\n    address _vKeyManager\n) = abi.decode(\n        initializeBytesAggchain,\n        (InitParams, bool, bytes32, bytes4, address)\n    );\n</code></pre></p> </li> <li> <p>custom bytes when calling <code>getAggchainHash</code> &amp; <code>onVerifyPessimistic</code>: <pre><code> // decode the aggchainData\n(\n    bytes4 _aggchainVKeySelector,\n    bytes32 _outputRoot,\n    uint256 _l2BlockNumber\n) = abi.decode(aggchainData, (bytes4, bytes32, uint256));\n</code></pre></p> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#521-roles","title":"5.2.1 Roles","text":"Role Description vKeyManager manages aggchain vkeys admin upgrade rollupTypes &amp; set trustedSequencer trustedSequencer if <code>optimisticMode</code>: signs state transition aggchainManager manages updates <code>submissionInterval</code> &amp; <code>rollupConfigHash</code>. Initialize the aggchain. optimisticModeManager enable/disable <code>optimisticMode</code>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#vkeymanager_2","title":"vKeyManager","text":"<ul> <li>Functionality: Manages aggchain verification keys, insertions and updates. It can also enable/disable the usage of the default aggchain vkeys (managed by the ALGateway contract)</li> <li>Security Assumptions: A malicious verification key can compromise the funds of a chain (not the entire agglayer)</li> <li>Recommended Account Type: Timelock (specified by the chain itself)</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#admin_2","title":"admin","text":"<ul> <li>Functionality: Allow to set the <code>trustedSequencer</code> and can manage aggchain upgrades with certain limitations:<ul> <li>cannot update to old <code>rollupTypeID</code></li> <li>cannot update to a different <code>rollupVerifierType</code></li> </ul> </li> <li>Security Assumptions: <code>trustedSequencer</code> signs the state-stransistion when the FEP is on <code>optimisticMode</code> (note that <code>optimisticMoode</code> has a higher level of security)</li> <li>Recommended Account Type: Multisig</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#trustedsequencer_1","title":"trustedSequencer","text":"<ul> <li>Functionality: Signs chain state-transistion in case the chain is on <code>optimisticMode</code></li> <li>Security Assumptions: Incorrect state-stransistion can lead to steal funds in the chain. Orotected by the security-council since it has no effect if the <code>optimisticMode</code> is not enabled</li> <li>Recommended Account Type: EOA or internal multisig</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#aggchainmanager","title":"aggchainManager","text":"<ul> <li>Functionality: Manages the update of the <code>submissionInterval</code> and the <code>rollupConfigHash</code> parameters</li> <li>Security Assumptions:<ul> <li><code>submissionInterval</code> is the minimum interval at which checkpoints must be submitted. No high security assumptions.</li> <li><code>rollupConfigHash</code> contains sensistive data that could potentially affect the aggchain state transistion. High security assumptions.</li> </ul> </li> <li>Recommended Account Type: Timelock (specified by the chain itself)</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#optimisticmodemanager","title":"optimisticModeManager","text":"<ul> <li>Functionality: Manages the enbale/disable of the <code>optimisticMode</code></li> <li>Security Assumptions: When true, the chain can bypass the state transition verification</li> <li>Recommended Account Type: Multisig security council. Act fast while and not fully controlled by internal people</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#522-test-vectors","title":"5.2.2 Test-vectors","text":"<ul> <li>aggchain-data</li> <li>aggchain-init-bytes-v0</li> <li>aggchain-init-bytes-v1</li> <li>hash-aggchain-params</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#6-rollup-manager-specification","title":"6. Rollup Manager Specification","text":""},{"location":"aggregation-layer/v0.3.0/SC-specs/#61-versioning","title":"6.1. Versioning","text":"<p>New string to indicate Rollup Manager version: <code>al-v0.3.1</code>: <pre><code>string public constant ROLLUP_MANAGER_VERSION = \"al-v0.3.1\";\n</code></pre></p>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#62-agglayergateway-contract","title":"6.2. AggLayerGateway contract","text":"<p>An address that identifies the <code>aggLayerGateway</code> contract. This will be set as an immutable: <pre><code>IAggLayerGateway public immutable aggLayerGateway;\n</code></pre></p>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#63-new-verifiertype","title":"6.3. New VerifierType","text":"<p>A new <code>VerifierType</code> has been added: <code>ALGateway</code> <pre><code>enum VerifierType {\n    StateTransition, // zkEVM &amp; Validium\n    Pessimistic, // PP v0.2.0\n    ALGateway // PP v0.3.0\n}\n</code></pre></p> <p><code>RollupTypes</code> created based on <code>VerifierType: ALGateway</code> will have the following properties:</p> <ul> <li>its verifier will be the <code>ALGateway</code> smart contract<ul> <li>the following rollup parameters will be 0:<ul> <li><code>rollup.forkID = 0;</code></li> <li><code>rollup.verifier = address(0);</code></li> <li><code>rollup.batchNumToStateRoot[0] = bytes32(0);</code></li> <li><code>rollup.programVKey = bytes32(0);</code></li> </ul> </li> </ul> </li> <li>a consensus will be predetermined (ECDSA or FEP)</li> </ul> <p>The chain can specify its own bytes to be initialized when the chain is created (not forced anymore by the interface): <pre><code>bytes memory initializeBytesAggchain\n</code></pre></p> <p>The chain can choose its own bytes when a proof is sent by tye aggLayer: <pre><code>bytes calldata aggchainData\n</code></pre></p>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#64-create-new-chain","title":"6.4. Create new chain","text":"<p>Chains will be created differently as it was in previous versions. Since the <code>initializeBytesAggchain</code> has been introduced to generalize the chains initialization, the entry point has been also generalized. Old chains will be still possible to create but it will be nececcesary to encode the ininitialization bytes in the <code>initializeBytesAggchain</code>. This approach provides a generic interface for all existing chains and allows future chains with different initialization bytes to be added without modifying the interface:</p> <pre><code>function attachAggchainToAL(\n    uint32 rollupTypeID,\n    uint64 chainID,\n    bytes memory initializeBytesAggchain\n) external;\n</code></pre>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#65-verify-pessimitic-proof","title":"6.5. Verify pessimitic proof","text":"<p>The entry point will be the same for every chain that uses pessimistic proof. That is the function <code>verifyPessimisticTrustedAggregator</code>. Its interface has been modified to initialize a v0.3.0 aggchain by inserting a new field <code>aggchainData</code>. <pre><code>function verifyPessimisticTrustedAggregator(\n    uint32 rollupID,\n    uint32 l1InfoTreeLeafCount,\n    bytes32 newLocalExitRoot,\n    bytes32 newPessimisticRoot,\n    bytes calldata proof,\n    bytes memory aggchainData\n) external;\n</code></pre></p> <p>For more information about the verification flow, you can refer to this link.</p>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#66-pretty-rollupdata","title":"6.6. Pretty rollupData","text":"<p>Etherscan did not parse structs correctly. A prettier view function has been added so the returning information is human-readable on etherscan. The following functions are the same, it is just a change on how the data is return:</p> <ul> <li> <p>v0.2.0: <pre><code>function rollupIDToRollupDataDeserialized(\n        uint32 rollupID\n)\n    public\n    view\n    returns (\n        address rollupContract,\n        uint64 chainID,\n        address verifier,\n        uint64 forkID,\n        bytes32 lastLocalExitRoot,\n        uint64 lastBatchSequenced,\n        uint64 lastVerifiedBatch,\n        uint64 _legacyLastPendingState,\n        uint64 _legacyLastPendingStateConsolidated,\n        uint64 lastVerifiedBatchBeforeUpgrade,\n        uint64 rollupTypeID,\n        VerifierType rollupVerifierType\n    );\n</code></pre></p> </li> <li> <p>v0.3.0: <pre><code>function rollupIDToRollupDataV2Deserialized(\n    uint32 rollupID\n)\n    public\n    view\n    returns (\n        address rollupContract,\n        uint64 chainID,\n        address verifier,\n        uint64 forkID,\n        bytes32 lastLocalExitRoot,\n        uint64 lastBatchSequenced,\n        uint64 lastVerifiedBatch,\n        uint64 lastVerifiedBatchBeforeUpgrade,\n        uint64 rollupTypeID,\n        VerifierType rollupVerifierType,\n        bytes32 lastPessimisticRoot,\n        bytes32 programVKey\n    )\n{\n    RollupData storage rollup = _rollupIDToRollupData[rollupID];\n\n    rollupContract = rollup.rollupContract;\n    chainID = rollup.chainID;\n    verifier = rollup.verifier;\n    forkID = rollup.forkID;\n    lastLocalExitRoot = rollup.lastLocalExitRoot;\n    lastBatchSequenced = rollup.lastBatchSequenced;\n    lastVerifiedBatch = rollup.lastVerifiedBatch;\n    lastVerifiedBatchBeforeUpgrade = rollup.lastVerifiedBatchBeforeUpgrade;\n    rollupTypeID = rollup.rollupTypeID;\n    rollupVerifierType = rollup.rollupVerifierType;\n    lastPessimisticRoot = rollup.lastPessimisticRoot;\n    programVKey = rollup.programVKey;\n}\n</code></pre></p> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#7-sovereign-scs-updates","title":"7. Sovereign SCs updates","text":"<p>This section introduces new features and functionalities in the Sovereign SC. Most are designed to support the FEP program.</p>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#71-globalexitrootmanagerl2sovereignchain","title":"7.1 GlobalExitRootManagerL2SovereignChain","text":""},{"location":"aggregation-layer/v0.3.0/SC-specs/#711-insertedgerhashchain-removedgerhashchain","title":"7.1.1 <code>insertedGERHashChain</code> &amp; <code>removedGERHashChain</code>","text":"<p>All GERs (Global Exit Roots) inserted on L2 must be verifiable against a valid <code>L1InfoTreeRoot</code>. This ensures the validity of every GER injected into the chain. However, an invalid GER may still be injected due to:</p> <ul> <li>malicious behavior by the <code>globalExitRootUpdater</code>, or  </li> <li>a bug in the GER injection process (e.g., in the <code>aggOracle</code> component).</li> </ul> <p>An invalid GER cannot be proven against any valid <code>L1InfoTreeRoot</code>, which will cause the chain to stall until that GER is removed.</p> <p>A na\u00efve approach would be to trigger a reorg on L2 to remove the offending GER transaction and reprocess subsequent transactions. But L2 reorgs are undesirable because they:</p> <ul> <li>severely damage chain and product reputation, and  </li> <li>could enable double-spending in third-party bridges.</li> </ul> <p>To avoid a reorg, the <code>removedGERHashChain</code> feature was introduced. Removing a GER in this context must be treated as an emergency action to restore progress without triggering a full reorg.</p>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#72-bridgel2sovereignchain","title":"7.2 BridgeL2SovereignChain","text":""},{"location":"aggregation-layer/v0.3.0/SC-specs/#721-unused-bits-on-globalindex-are-set-to-0","title":"7.2.1 Unused bits on <code>globalIndex</code> are set to 0","text":"<p>Forces all unused bits on the <code>globalIndex</code> to be set to 0. This has no implication on <code>hermez-prover</code> chains, but it does affect <code>PP</code> and <code>FEP</code> chains, since <code>globalIndex</code> is used in both the pessimistic and FEP programs.</p> <p>Both programs assume that the unused bits are 0. Therefore, if any user makes a claim where those bits are set to a non-zero value, it could potentially trigger an error in the program, making it impossible to generate a proof.</p> <p>To resolve this, a change was introduced directly in the smart contract to prevent the propagation of unused bits to other components. </p> <p>Note: An alternative solution could have been modifying the components to allow arbitrary values for the unused bits.</p>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#722-localbalancetree","title":"7.2.2 LocalBalanceTree","text":"<p>The contract implements the same <code>LocalBalanceTree</code> logic as the pessimistic program. This tree is stored in a mapping and behaves as follows:</p> <ul> <li>Decreases when a <code>bridge</code> occurs.</li> <li>Increases when a <code>claim</code> is made.</li> <li>If the token is minted on the chain itself, it does not alter the balance (no increase/decrease).</li> </ul> <p>This tree was added to prevent the following scenario:</p> <ol> <li>A chain uses a custom mapping that allows minting more tokens than are actually available.</li> <li>A user performs a successful <code>bridge</code> with more tokens than exist on the chain.</li> <li>The user transaction succeeds, but the pessimistic program cannot generate a valid proof because the <code>LocalBalanceTree</code> becomes negative.</li> <li>The chain gets blocked until a <code>claim</code> is performed to inject tokens into the <code>LocalBalanceTree</code>.</li> </ol> <p>This situation is avoided by having the <code>LocalBalanceTree</code> in the smart contract. Any <code>bridge</code> that would cause a negative balance is automatically reverted.</p>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#723-activateemergencystate-deactivateemergencystate","title":"7.2.3 <code>activateEmergencyState</code> &amp; <code>deactivateEmergencyState</code>","text":"<p>Adds the ability to pause and unpause the bridge. Each action is controlled by its own dedicated address:</p> <ul> <li><code>activateEmergencyState</code> \u2192 <code>emergencyBridgePauser</code></li> <li><code>deactivateEmergencyState</code> \u2192 <code>emergencyBridgeUnpauser</code></li> </ul> <p>This functionality should be treated as an emergency mechanism. Entering into an emergency state should be executed by a <code>security council</code> address to act swiftly while requiring external consensus to trigger the action.</p> <p>Re-enabling the bridge (i.e., deactivating the emergency state) does not introduce any security concerns, so it can be safely managed by a multisig controlled by the chain itself.</p>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#724-claimedglobalindexhashchain-unsetglobalindexhashchain","title":"7.2.4 <code>claimedGlobalIndexHashChain</code> &amp; <code>unsetGlobalIndexHashChain</code>","text":"<p>Every claim made on L2 must correspond to a claim processed by the pessimistic program. To enforce this, the contract tracks a hash chain of all claims, which the program must reconstruct.</p> <p>If an invalid GER was used (as noted in section 7.2), it can lead to invalid claims on L2. In this situation:</p> <ol> <li>A reorg has not occurred, but  </li> <li>Invalid claims exist due to the bad GER.</li> </ol> <p>These invalid claims can leave the pessimistic program in a state where some claims cannot be proven. To rectify this, the <code>unsetMultipleClaims</code> function was added, allowing invalid claims to be rolled back. Like GER removal, this must be treated as an emergency action and triggered before any investigation.</p> <p>Important note: When a claim is unset, the user still receives their funds from the Bridge, meaning the Bridge\u2019s balance becomes incorrect. It\u2019s up to the chain itself to rebalance the Bridge (e.g., by bridging tokens and sending them to <code>0x00...00</code>).</p>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#8-roles-sovereignchains-contracts","title":"8. Roles sovereignChains contracts","text":"<p>Contracts used in sovereign chains: <code>BridgeL2SovereignChain</code> &amp; <code>GlobalExitRootManagerL2SovereignChain</code></p>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#81-bridgel2sovereignchain","title":"8.1. BridgeL2SovereignChain","text":"Role Description bridgeManager Handles set custom tokens mapping and has the ability to clear claims"},{"location":"aggregation-layer/v0.3.0/SC-specs/#bridgemanager","title":"bridgeManager","text":"<ul> <li>Functionality: Manages the custom tokens mapping. It also has the ability to clear claims</li> <li>Security Assumptions: High. Setting custom tokens or clear claims</li> <li>Recommended Account Type: Timelock (specified by the chain itself)</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#82-globalexitrootmanagerl2sovereignchain","title":"8.2. GlobalExitRootManagerL2SovereignChain","text":"Role Description globalExitRootUpdater Inject GER into the bridge SC globalExitRootRemover Removes GER from the Bridge SC"},{"location":"aggregation-layer/v0.3.0/SC-specs/#globalexitrootupdater","title":"globalExitRootUpdater","text":"<ul> <li>Functionality: Injects GER to the bridge SC</li> <li>Security Assumptions: Low security risk. All GERS are validated via the FEP program.</li> <li>Recommended Account Type: EOA (hot wallet in aggOracle)</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#globalexitrootupdater_1","title":"globalExitRootUpdater","text":"<ul> <li>Functionality: Remove GER to the bridge SC</li> <li>Security Assumptions: High security risk. Controller could steal funds if collide with the <code>globalExitRootUpdater</code></li> <li>Recommended Account Type: Multisg (act fast to unblock the chain)</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#smart-contracts-version-updates","title":"Smart contracts version updates","text":""},{"location":"aggregation-layer/v0.3.0/SC-specs/#open-zeppelin","title":"Open zeppelin","text":""},{"location":"aggregation-layer/v0.3.0/SC-specs/#updated-openzeppelincontracts500-to-openzeppelincontracts520","title":"Updated <code>openzeppelin/contracts@5.0.0</code> to <code>openzeppelin/contracts@5.2.0</code>","text":"<ul> <li>Rationale: When implementing <code>ReentrancyGuard</code> at <code>PolygonRollupManager</code>, it's very suitable to use the <code>ReentrancyGuardTransient.sol</code> that is only available at <code>openzeppelin/contracts@5.2.0</code> because it doesn't modify the storage layer as is using the reentrancy variable as transient.</li> <li>Changes:<ul> <li><code>openzeppelin/contracts@5.0.0</code> is used in the following contracts <code>TransparentUpgradeableProxy</code>, <code>ERC1967Proxy</code>, <code>IERC1967</code> and <code>ProxyAdmin</code> which remain unchanged bumping the version.</li> <li><code>ERC1967Utils</code> is also used but it has \"breaking changes\": https://github.com/OpenZeppelin/openzeppelin-contracts/releases/tag/v5.1.0-rc.0 : Removed duplicate declaration of the Upgraded, AdminChanged and BeaconUpgraded events. These events are still available through the IERC1967 interface located under the contracts/interfaces/ directory. Minimum pragma version is now 0.8.21. This change doesn't break anything because the events are still visible exactly the same way from the aforementioned interface.</li> </ul> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-specs/#update-pragma-version-0820-to-0828","title":"Update pragma version <code>0.8.20</code> to <code>0.8.28</code>","text":"<ul> <li>Rationale: Bumping to <code>0.8.28</code> has many features<ul> <li>Stack-to-memory mover always enabled via-IR: link</li> <li>Support transient storage link</li> <li>MCOPY opcode (gas optimizations) link</li> <li>Custom errors support require link</li> <li>Full support for transient state variables link</li> </ul> </li> <li>Changes:<ul> <li>The bytecode of the compiled contracts has changed -&gt; A new folder with all the contracts with the previous version has been created for upgrading testing purposes</li> <li>The TransparentProxys created by rollup manager when a rollup is created now they will have a different bytecode</li> </ul> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/Tooling/","title":"Tooling","text":""},{"location":"aggregation-layer/v0.3.0/Tooling/#add-new-rollup-type","title":"Add new rollup type","text":"addNewRollupType <p>Tool to call <code>addNewRollupType</code> function.</p> <p>This tool adds a new rollup type to <code>PolygonRollupManager</code> contract. </p> <ol> <li>Go to repository: agg-contracts-internal.</li> <li>You can use this tool to add new rollup type<ul> <li>Follow the steps found in this README.</li> <li>Set parameters <code>add_rollup_type.json</code>.</li> <li>Run tool <code>npx hardhat run ./tools/addRollupType/addRollupType.ts --network &lt;network&gt;</code></li> </ul> </li> </ol>"},{"location":"aggregation-layer/v0.3.0/Tooling/#create-new-rollup-attachaggchaintoal","title":"Create new rollup (attachAggchainToAL)","text":"attachAggchainToAL <p>Tool to call <code>attachAggchainToAL</code> function.</p> <p>This tool adds a new aggchain to <code>PolygonRollupManager</code> contract. </p> <ol> <li>Go to repository: agg-contracts-internal.</li> <li>You can use this tool to add new chain<ul> <li>Follow the steps found in this README.</li> <li>Set parameters <code>create_new_rollup.json</code>.</li> <li>Copy <code>genesis.json</code> file</li> <li>Run tool <code>npx hardhat run ./tools/createNewRollup/createNewRollup.ts --network &lt;network&gt;</code></li> </ul> </li> </ol>"},{"location":"aggregation-layer/v0.3.0/Tooling/#upate-rollup","title":"Upate rollup","text":"updateRollup <p>Tool to call <code>updateRollup</code> function.</p> <p>This tool update rollup to new rollup type in <code>PolygonRollupManager</code> contract.</p> <ol> <li>Go to repository: agg-contracts-internal.</li> <li>You can use this tool to update rollup to new type<ul> <li>Follow the steps found in this README.</li> <li>Set parameters <code>updateRollup.json</code></li> <li>Run tool <code>npx hardhat run ./tools/updateRollup/updateRollup.ts --network &lt;network&gt;</code></li> </ul> </li> </ol>"},{"location":"aggregation-layer/v0.3.0/UpgradeableTokens/","title":"UpgradeableTokens","text":"<ul> <li>UpgradeableTokens<ul> <li>1. Glossary</li> <li>2. Rationale<ul> <li>2.1 Current scenario</li> <li>2.2 Current issue</li> <li>2.3 Solving the issue</li> </ul> </li> <li>3. Requirements</li> <li>4. Cases<ul> <li>4.1 New SovereignBridges deployed</li> <li>4.2 Previous bridges deployed</li> <li>4.3 Chains with no PP (zkEVM / Validium / Mainnet)</li> </ul> </li> <li>5. Specs<ul> <li>5.1 Deterministic address specification</li> <li>5.2 Previous knowledge</li> <li>5.3 Create2 params TransparentProxy<ul> <li>5.3.1 deployer</li> <li>5.3.2 salt</li> <li>5.3.4 init_code</li> </ul> </li> <li>5.4 Implementation</li> </ul> </li> </ul> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/UpgradeableTokens/#1-glossary","title":"1. Glossary","text":"<ul> <li><code>wrappedToken</code>: ERC20 standard token created by the bridge</li> <li><code>upgradeableWrappedToken</code>: TransparentProxy pointing to a ERC20 standard upgradeable implementation</li> </ul>"},{"location":"aggregation-layer/v0.3.0/UpgradeableTokens/#2-rationale","title":"2. Rationale","text":""},{"location":"aggregation-layer/v0.3.0/UpgradeableTokens/#21-current-scenario","title":"2.1 Current scenario","text":"<p>Wrapped tokens are created by the bridge using the create2 opcode and it creates a simple and standard ERC20 token. Note that current deployed chains use this approach to create wrappedTokens and wrapped tokens have the same addresses in all chains deployed. This approach does not imply any security assumption beyond the address that is able to upgrade the bridge (normally a timelock).  </p>"},{"location":"aggregation-layer/v0.3.0/UpgradeableTokens/#22-current-issue","title":"2.2 Current issue","text":"<p>On SovereignChains, a new approach to allow more features on the wrapped Tokens has been implemented: custom mappings. This feature currently works given the featured wanted: extend the wrappedToken features.</p> <p>This feature is purely managed by the <code>bridgeManager</code> meaning that this feature is chain-centric (instead of asset-centric). Asset-centric means that the owner of the asset could deploy its own wrappedToken (or similarly, deploy an upgradeable wrappedToken and give the ownership to an address controlled by the asset). An asset-centric feature could not be applied on top of the <code>custom mappings</code> implementation. Therefore a new approach needs to be specified in order to allow future version to be asset-centric.</p> <p>Besides, this approach implies another risky concern about users being able to stop the PP of the chain if LBT reaches a negative balance (this assumption purely depends on the approach on how to use the customMappings. Example: Katana). The implementation of the LBT at SC level provides guarantees that the PP will not be blocked, but just the user claim. NOTE that this affects <code>customMappings</code> and <code>upgradeableWrappedTokens</code>.</p>"},{"location":"aggregation-layer/v0.3.0/UpgradeableTokens/#23-solving-the-issue","title":"2.3 Solving the issue","text":"<p>Deploy transparent proxy which has a ERC20 upgradeable implementation</p> <ul> <li><code>proxiedTokensManager</code> is the owner of the proxy admin of the proxy</li> <li><code>proxiedTokensManager</code> can delegate ownership to any address later on</li> <li><code>proxiedTokensManager</code> is set at initialization of sovereign bridge from initialization inputs. In case of L1, bridgeV2, <code>proxiedTokensManager</code> is set from the proxy owner of the proxy admin of the bridge itself. The role can be transferred with a two steps procedure.</li> </ul> <p>Security assumptions:</p> <ul> <li><code>SovereignBridge</code> is a proxy controlled by a certain address. Managing the tokens from the same address has the same security assumptions.</li> <li>LBT implementation avoids chain DoS on the PP, more specifically on the LBT with negative value given that an asset could <code>mint</code> tokens as its wish</li> <li>mainnet bridge to produce the same addresses once it is upgraded</li> </ul> <p>Custom mappings:</p> <ul> <li>keep functionality on SovereignBridges</li> <li>theoretically, functionality will not be used and therefore removed in future versions</li> </ul> <p>\u26a0 \ud83d\udca1 Already deployed SovereignBridges can have an extra functionality which is deploying the new <code>upgradeableWrappedTokens</code>. Then, a customMapping could be done to override the <code>wrappedToken</code> address. CustomMappings provides the ability to migrate tokens if used correctly.</p> <p>If the <code>upgradeableWrappedTokens</code> mints outside the bridge could potentially unbalance the liquidity and/or steal user's assets</p>"},{"location":"aggregation-layer/v0.3.0/UpgradeableTokens/#3-requirements","title":"3. Requirements","text":"<ul> <li>Deterministic addresses on all chains</li> <li>Mainnet bridge and SovereignBridges to deploy new <code>upgradeableWrappedTokens</code></li> <li><code>upgradeableWrappedTokens</code> pointing to a ERC20 standard upgradeable implementation</li> <li><code>upgradeableWrappedTokens</code> to set <code>bridgeManager</code> as its initial owner</li> <li>keep <code>customMappings</code> feature</li> </ul>"},{"location":"aggregation-layer/v0.3.0/UpgradeableTokens/#4-cases","title":"4. Cases","text":""},{"location":"aggregation-layer/v0.3.0/UpgradeableTokens/#41-new-sovereignbridges-deployed","title":"4.1 New SovereignBridges deployed","text":"<p>All the tokens created by the <code>SovereignBridge</code> will have the new addresses and will be upgradeable ERC20 tokens. Mainnet bridge will also produce the same addresses once the bridge is upgraded.</p> <p>\u26a0 Previous tokens deployed by the bridge will still have the old addresses and will not be upgraded. therefore, old address will have all the token liquidity. There will not be liquidity fragmentation.</p> <p>\ud83d\udca1 A mechanism to upgrade previous tokens has been introduced <code>deployWrappedTokenAndRemap</code>.Function to deploy an upgradeable wrapped token without having to claim asset. It is used to upgrade legacy tokens to the new upgradeable token. After deploying the token it is remapped to be the new functional wtoken. This function can only be called once for each originNetwork/originTokenAddress pair because it deploys a deterministic contract with create2</p> <p>All tokens created by the bridge will effectively not have the same address as previous <code>wrappedToken</code> versions.</p>"},{"location":"aggregation-layer/v0.3.0/UpgradeableTokens/#42-previous-bridges-deployed","title":"4.2 Previous bridges deployed","text":"<p>Bridges will be upgraded to start using <code>upgradeableWrappedTokens</code>. All previous tokens deployed on those bridges will have the same address as before and same address will be used. New tokens will have the new address produced by the <code>upgradeableWrappedToken</code>.  </p>"},{"location":"aggregation-layer/v0.3.0/UpgradeableTokens/#43-chains-with-no-pp-zkevm-validium-mainnet","title":"4.3 Chains with no PP (zkEVM / Validium / Mainnet)","text":"<p>Chains with NO PP proofs cannot use this feature since all bridge assets can be stolen, not just the chain's ones. Mainnet could be a special case where the owner of the <code>upgradeableWrappedTokens</code> is the <code>securityCouncil</code></p> <p><code>securityCouncil</code> is the same address that could potentially halt the bridge and <code>zkEVMMultisig</code> to perform an upgrade with delay 0 afterwards</p> <p>therefore, seems more rational to setup the timelock as the owner of all <code>upgradeableWrappedTokens</code></p> <p>Timelock is not accessible from the Bridge. Therefore, adding a role <code>bridgeManager</code> and initialize it with the timelock fits better. Later on, bridgeManager can be initialized as the securityCouncil address or the timelock.</p>"},{"location":"aggregation-layer/v0.3.0/UpgradeableTokens/#5-specs","title":"5. Specs","text":""},{"location":"aggregation-layer/v0.3.0/UpgradeableTokens/#51-deterministic-address-specification","title":"5.1 Deterministic address specification","text":"<p>In order to get a deterministic address when deploying a ERC20 upgradeable token we need to make the <code>create2</code> parameters to be only dependant on the token information. The rest of the parameters must be equal across all the chains. The common data shared among all the bridges deployed is its address.</p>"},{"location":"aggregation-layer/v0.3.0/UpgradeableTokens/#52-previous-knowledge","title":"5.2 Previous knowledge","text":"<p><code>create2</code> formula to generate addresses: <pre><code>address = keccak256(0xFF ++ deployer ++ salt ++ keccak256(init_code))[12:]\n</code></pre> ProxyTransparentProxy constructor parameters: - <code>_logic</code>: implementation address - <code>initialOwner</code>: owner of the proxy - <code>_data</code>:  typically to initialize storage proxy</p>"},{"location":"aggregation-layer/v0.3.0/UpgradeableTokens/#53-create2-params-transparentproxy","title":"5.3 Create2 params TransparentProxy","text":""},{"location":"aggregation-layer/v0.3.0/UpgradeableTokens/#531-deployer","title":"5.3.1 deployer","text":"<p>The deployer will be always the bridge address when the proxy is deployed</p>"},{"location":"aggregation-layer/v0.3.0/UpgradeableTokens/#532-salt","title":"5.3.2 salt","text":"<p>The TokenInfoHash will be set as a <code>salt</code> since it is the unique identifier of a given token.</p> <p>Note that in previous bridge versions, not only the <code>TokenInfoHash</code> changed the address deployed but also the token metadata since it was appended to the initBytecode to be able to setup the constructor.</p>"},{"location":"aggregation-layer/v0.3.0/UpgradeableTokens/#534-init_code","title":"5.3.4 init_code","text":"<p>initBytecode <code>proxyInitBytecode # constructorArgs</code>: <pre><code>/// @dev A bytecode stored on chain is used to deploy the proxy in a way that ALWAYS it's used the same\n/// bytecode, therefore the proxy addresses are the same in all chains as they are deployed deterministically with same init bytecode\n/// @dev there is no constructor args as the implementation address + owner of the proxied are set at constructor level and taken from the bridge itself\nbytes memory proxyInitBytecode = abi.encodePacked(\n    INIT_BYTECODE_TRANSPARENT_PROXY()\n);\n</code></pre> Here it is the most tricky part since as mentioned before, the constructor arguments of the proxy are the following:</p> <ul> <li><code>_logic</code>: implementation address</li> <li><code>initialOwner</code>: owner of the proxy</li> <li><code>_data</code>:  typically to initialize storage proxy Therefore, all above parameters must be the same in all chains in order to get the same address.</li> </ul>"},{"location":"aggregation-layer/v0.3.0/UpgradeableTokens/#54-implementation","title":"5.4 Implementation","text":"<ul> <li>When deploying the new bridge implementation<ul> <li>deploy proxy init bytecode and store it on an immutable address</li> <li>deploy erc20 upgradeable implementation and store it on an immutable address</li> </ul> </li> <li>When deploying a new upgradeableWrappedToken<ul> <li>Deploy TokenWrappedTransparentProxy with create2<ul> <li>The constructor has been modified to get the params from the msg.sender (the bridge). This way, we are not sending constructor args and the init code it's no dependant on constructor and the address is determined byt the bytecode. <pre><code>   constructor()\n        payable\n        ERC1967Proxy(\n            IPolygonZkEVMBridgeV2(msg.sender)\n                .getWrappedTokenBridgeImplementation(),\n            new bytes(0)\n        )\n    {\n        // Get bridge interface to retrieve proxied tokens manager role\n        _changeAdmin(\n            IPolygonZkEVMBridgeV2(msg.sender).getProxiedTokensManager()\n        );\n    }\n</code></pre></li> </ul> </li> <li>attach <code>initBytecodeProxy</code> with params <pre><code>// 'proxyBytecodeStorer' is the address that contains the initBytecode\nbytes memory initBytecode = abi.encodePacked(\n    IProxyInitCode(wrappedTokenBytecodeStorer).PROXY_INIT_BYTECODE();,\n    constructorArgsProxy\n);\n</code></pre></li> <li>create2 opcode <pre><code>/// @solidity memory-safe-assembly\nassembly {\n    newWrappedTokenProxy := create2(\n        0,\n        add(initBytecode, 0x20),\n        mload(initBytecode),\n        tokenInfoHash\n    )\n}\n</code></pre></li> <li>initialize proxy contract <pre><code>newWrappedTokenProxy.initialize(name, symbol, decimals);\n</code></pre></li> </ul> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggLayerGateway/","title":"AggLayer Gateway SC","text":"<ul> <li>AggLayer Gateway SC<ul> <li>1. Interactions &amp; Usage<ul> <li>1.1. addPessimisticVKeyRoute</li> <li>1.2. freezePessimisticVKeyRoute</li> <li>1.3. addDefaultAggchainVKey</li> <li>1.4. updateDefaultAggchainVKey</li> <li>1.5. unsetDefaultAggchainVKey</li> <li>1.6. getDefaultAggchainVKey</li> <li>1.7. verifyPessimisticProof</li> </ul> </li> <li>2. Tooling available<ul> <li>2.1. deployment AggLayerGateway</li> <li>2.2. Add default aggchain vkey</li> <li>2.3. Update default aggchain vkey</li> <li>2.4. Unset default aggchain vkey</li> <li>2.5. Add pessimistic vkey route</li> <li>2.6. Freeze pessimistic vkey route</li> </ul> </li> </ul> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggLayerGateway/#1-interactions-usage","title":"1. Interactions &amp; Usage","text":"<p>The definition can be found here.</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggLayerGateway/#11-addpessimisticvkeyroute","title":"1.1. addPessimisticVKeyRoute","text":"<p>Function to add a pessimistic verification key route.</p> <p>Parameters: <pre><code>@param pessimisticVKeySelector The 4 bytes selector to add to the pessimistic verification keys.\n@param verifier The address of the verifier contract.\n@param pessimisticVKey New pessimistic program verification key\n</code></pre></p> <p>Events: <pre><code>@param selector The verifier selector that was added.\n@param verifier The address of the verifier contract.\n@param pessimisticVKey The verification key\n\nevent RouteAdded(\n    bytes4 selector,\n    address verifier,\n    bytes32 pessimisticVKey\n)\n</code></pre></p> <p>Errors:</p> <ul> <li>Thrown when adding a verifier route and the selector returned by the verifier is zero: <pre><code>error PPSelectorCannotBeZero();\n</code></pre></li> <li>Thrown when adding a verifier route and the selector already contains a route: <pre><code>@param selector The pessimistic verification key selector that was specified.\n@param verifier The address of the verifier contract in the existing route.\n\nerror RouteAlreadyExists(bytes4 selector, address verifier);\n</code></pre></li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggLayerGateway/#12-freezepessimisticvkeyroute","title":"1.2. freezePessimisticVKeyRoute","text":"<p>Function to freeze a pessimistic verification key route.</p> <p>Parameters: <pre><code>@param pessimisticVKeySelector The 4 bytes selector to freeze the pessimistic verification key route\n</code></pre></p> <p>Events: <pre><code>@param selector The verifier selector that was added.\n@param verifier The address of the verifier contract.\n@param pessimisticVKey The verification key\n\nevent RouteFrozen(\n    bytes4 selector,\n    address verifier,\n    bytes32 pessimisticVKey\n);\n</code></pre></p> <p>Errors:</p> <ul> <li> <p>Thrown when the verifier route is not found: <pre><code>@param selector The verifier selector that was specified\n\nerror RouteNotFound(bytes4 selector);\n</code></pre></p> </li> <li> <p>Thrown when trying to freeze a route that is already frozen: <pre><code>@param selector The pessimistic verification key selector that was specified\n\nerror RouteIsAlreadyFrozen(bytes4 selector);\n</code></pre></p> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggLayerGateway/#13-adddefaultaggchainvkey","title":"1.3. addDefaultAggchainVKey","text":"<p>Function to add an aggchain verification key.</p> <p>Parameters: <pre><code>@param defaultAggchainSelector The 4 bytes selector to add to the default aggchain verification keys.\n@dev First 2 bytes of the selector  are the 'verification key identifier', the last 2 bytes are the aggchain type (ex: FEP, ECDSA)\n@param defaultAggchainVKey New default aggchain verification key to be added\n</code></pre></p> <p>Events: <pre><code>@param selector The 4 bytes selector of the added default aggchain verification key.\n@param newVKey New aggchain verification key to be added\n\nevent AddDefaultAggchainVKey(bytes4 selector, bytes32 newVKey);\n</code></pre></p> <p>Errors:</p> <ul> <li>Thrown when trying to add an aggchain verification key that already exists: <pre><code>error AggchainVKeyAlreadyExists();\n</code></pre></li> <li>Thrown when adding a verifier key with value zero: <pre><code>error VKeyCannotBeZero();\n</code></pre></li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggLayerGateway/#14-updatedefaultaggchainvkey","title":"1.4. updateDefaultAggchainVKey","text":"<p>Function to update a default aggchain verification key from the mapping.</p> <p>Parameters: <pre><code>@param defaultAggchainSelector The 4 bytes selector to update the default aggchain verification keys.\n@param newDefaultAggchainVKey Updated default aggchain verification key value\n</code></pre></p> <p>Events: <pre><code>@param selector The 4 bytes selector of the updated default aggchain verification key.\n@param previousVKey Aggchain verification key previous value\n@param newVKey Aggchain verification key updated value\n\nevent UpdateDefaultAggchainVKey(\n    bytes4 selector,\n    bytes32 previousVKey,\n    bytes32 newVKey\n);\n</code></pre></p> <p>Errors:</p> <ul> <li>Thrown when trying to retrieve an aggchain verification key from the mapping that doesn't exists: <pre><code>error AggchainVKeyNotFound();\n</code></pre></li> <li>Thrown when new defaultAggchainVKey is zero: <pre><code>error VKeyCannotBeZero();\n</code></pre></li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggLayerGateway/#15-unsetdefaultaggchainvkey","title":"1.5. unsetDefaultAggchainVKey","text":"<p>Function to unset a default aggchain verification key from the mapping.</p> <p>Parameters: <pre><code>@param defaultAggchainSelector The 4 bytes selector to update the default aggchain verification keys\n</code></pre></p> <p>Events: <pre><code>@param selector The 4 bytes selector of the updated default aggchain verification key\n\nevent UnsetDefaultAggchainVKey(\n    bytes4 selector\n);\n</code></pre></p> <p>Errors:</p> <ul> <li>Thrown when trying to retrieve an aggchain verification key from the mapping that doesn't exists: <pre><code>error AggchainVKeyNotFound();\n</code></pre></li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggLayerGateway/#16-getdefaultaggchainvkey","title":"1.6. getDefaultAggchainVKey","text":"<p>Function to retrieve the default aggchain verification key.</p> <p>Parameters: <pre><code>@param defaultAggchainSelector The default aggchain selector for the verification key.\n@dev First 2 bytes are the aggchain type, the last 2 bytes are the 'verification key identifier'.\n</code></pre></p> <p>Errors:</p> <ul> <li>Thrown when trying to retrieve an aggchain verification key from the mapping that doesn't exists: <pre><code>error AggchainVKeyNotFound();\n</code></pre></li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggLayerGateway/#17-verifypessimisticproof","title":"1.7. verifyPessimisticProof","text":"<p>Function to verify the pessimistic proof.</p> <p>Parameters: <pre><code>@param publicValues Public values of the proof.\n@param proofBytes Proof for the pessimistic verification.\n@dev First 4 bytes of the pessimistic proof are the pp selector.\n proof[0:4]: 4 bytes selector pp\n proof[4:8]: 4 bytes selector SP1 verifier\n proof[8:]: proof\n</code></pre></p> <p>Errors:</p> <ul> <li> <p>Thrown when the verifier route is not found: <pre><code>@param selector The verifier selector that was specified\n\nerror RouteNotFound(ppSelector)\n</code></pre></p> </li> <li> <p>Thrown when the verifier route is found, but is frozen: <pre><code>@param selector The verifier selector that was specified\n\nerror RouteIsFrozen(ppSelector)\n</code></pre></p> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggLayerGateway/#2-tooling-available","title":"2. Tooling available","text":""},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggLayerGateway/#21-deployment-agglayergateway","title":"2.1. deployment AggLayerGateway","text":"<p>Tool to deploy <code>AggLayerGateway</code> contract.</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggLayerGateway/#22-add-default-aggchain-vkey","title":"2.2. Add default aggchain vkey","text":"<p>Tool to add default aggchain vkey.</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggLayerGateway/#23-update-default-aggchain-vkey","title":"2.3. Update default aggchain vkey","text":"<p>Tool to update default aggchain vkey.</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggLayerGateway/#24-unset-default-aggchain-vkey","title":"2.4. Unset default aggchain vkey","text":"<p>Tool to unset default aggchain vkey.</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggLayerGateway/#25-add-pessimistic-vkey-route","title":"2.5. Add pessimistic vkey route","text":"<p>Tool to add pessimitic vkey route.</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggLayerGateway/#26-freeze-pessimistic-vkey-route","title":"2.6. Freeze pessimistic vkey route","text":"<p>Tool to freeze pessimistic vkey route.</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/","title":"Aggchain FEP","text":"<ul> <li>Aggchain FEP<ul> <li>1. Interactions &amp; Usage<ul> <li>1.1. Initialize AggchainFEP</li> <li>1.2. View functions<ul> <li>1.2.1. getAggchainHash</li> <li>1.2.2. SUBMISSION_INTERVAL</li> <li>1.2.3. L2_BLOCK_TIME</li> <li>1.2.4. getL2Output</li> <li>1.2.5. latestOutputIndex</li> <li>1.2.6. nextOutputIndex</li> <li>1.2.7. latestBlockNumber</li> <li>1.2.8. nextBlockNumber</li> <li>1.2.9. computeL2Timestamp</li> </ul> </li> <li>1.3. onVerifyPessimistic</li> <li>1.4. updateSubmissionInterval</li> <li>1.5. updateAggregationVkey</li> <li>1.6. updateRangeVkeyCommitment</li> <li>1.7. updateRollupConfigHash</li> <li>1.8. enableOptimisticMode/disableOptimisticMode</li> <li>1.9. transferAggchainManagerRole/acceptAggchainManagerRole</li> <li>1.10. transferOptimisticModeManagerRole/acceptOptimisticModeManagerRole</li> </ul> </li> <li>2. Tooling available<ul> <li>2.1. Change optimistic mode</li> <li>2.2. Transfer aggchain manager</li> <li>2.3. Transfer optimistic mode manager role</li> <li>2.4. Update rollup config hash</li> <li>2.5. Update submission interval</li> <li>2.6. Tools to get aggchain data</li> </ul> </li> </ul> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#1-interactions-usage","title":"1. Interactions &amp; Usage","text":"<p>The definition can be found here.</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#11-initialize-aggchainfep","title":"1.1. Initialize AggchainFEP","text":"<p>To initialize the aggchain, it is necessary to differentiate according to the <code>initializerVersion</code>:</p> <ul> <li> <p><code>initializeBytesAggchain</code> if <code>_initializerVersion == 0</code>: <pre><code> // chain custom params\nInitParams memory _initParams\n// aggchainBase params\nbool _useDefaultGateway\nbytes32 _initOwnedAggchainVKey\nbytes2 _initAggchainVKeyVersion\naddress _vKeyManager\n// PolygonConsensusBase params\naddress _admin\naddress _trustedSequencer\naddress _gasTokenAddress\nstring memory _trustedSequencerURL\nstring memory _networkName\n</code></pre></p> </li> <li> <p><code>initializeBytesAggchain</code> if <code>_initializerVersion == 1</code>: <pre><code>// chain custom params\nInitParams memory _initParams,\n// aggchainBase params\nbool _useDefaultGateway,\nbytes32 _initOwnedAggchainVKey,\nbytes2 _initAggchainVKeyVersion,\naddress _vKeyManager\n</code></pre></p> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#12-view-functions","title":"1.2. View functions","text":""},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#121-getaggchainhash","title":"1.2.1. getAggchainHash","text":"<p>Function to get resulting aggchain hash.</p> <p>Parameters: <pre><code>@param aggchainData custom bytes provided by the chain\n\n    aggchainData:\n        Field:           | _aggchainVKeyVersion | _outputRoot  | _l2BlockNumber |\n        length (bits):   | 16                   | 256          | 256            |\n\n    aggchainData._aggchainVKeyVersion First 2 bytes of the aggchain vkey selector\n    aggchainData._outputRoot Proposed new output root\n    aggchainData._l2BlockNumber Proposed new l2 bock number\n</code></pre></p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#122-submission_interval","title":"1.2.2. SUBMISSION_INTERVAL","text":"<p>Getter for the submissionInterval.</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#123-l2_block_time","title":"1.2.3. L2_BLOCK_TIME","text":"<p>Getter for the l2BlockTime.</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#124-getl2output","title":"1.2.4. getL2Output","text":"<p>Returns an output by index. Needed to return a struct instead of a tuple.</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#125-latestoutputindex","title":"1.2.5. latestOutputIndex","text":"<p>Returns the number of outputs that have been proposed. Will revert if no outputs have been proposed yet.</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#126-nextoutputindex","title":"1.2.6. nextOutputIndex","text":"<p>Returns the index of the next output to be proposed.</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#127-latestblocknumber","title":"1.2.7. latestBlockNumber","text":"<p>Returns the block number of the latest submitted L2 output proposal. If no proposals been submitted yet then this function will return the starting block number.</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#128-nextblocknumber","title":"1.2.8. nextBlockNumber","text":"<p>Computes the block number of the next L2 block that needs to be checkpointed.</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#129-computel2timestamp","title":"1.2.9. computeL2Timestamp","text":"<p>Returns the L2 timestamp corresponding to a given L2 block number.</p> <p>Parameters: <pre><code>@param _l2BlockNumber The L2 block number of the target block.\n</code></pre></p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#13-onverifypessimistic","title":"1.3. onVerifyPessimistic","text":"<p>Callback when pessimistic proof is verified, can only be called by the rollup manager stores the necessary chain data when the pessimistic proof is verified.</p> <p>Parameters: <pre><code>@param aggchainData Custom data provided by the chain\n</code></pre></p> <p>Events: <pre><code>emit OutputProposed(outputRoot, l2OutputIndex, l2BlockNumber, l1Timestamp);\n</code></pre></p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#14-updatesubmissioninterval","title":"1.4. updateSubmissionInterval","text":"<p>Function to update the submission interval.</p> <p>Parameters: <pre><code>@param _submissionInterval The new submission interval\n</code></pre></p> <p>Events: <pre><code>@param oldSubmissionInterval The old submission interval.\n@param newSubmissionInterval The new submission interval.\n\nevent SubmissionIntervalUpdated(uint256 oldSubmissionInterval, uint256 newSubmissionInterval)\n</code></pre></p> <p>Errors:</p> <ul> <li>Thrown when new submission interval is 0: <pre><code>error SubmissionIntervalMustBeGreaterThanZero()\n</code></pre></li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#15-updateaggregationvkey","title":"1.5. updateAggregationVkey","text":"<p>Function to update the aggregation verification key.</p> <p>Parameters: <pre><code>@param _aggregationVkey The new aggregation verification key.\n</code></pre></p> <p>Events: <pre><code>@param oldAggregationVkey The old aggregation verification key.\n@param newAggregationVkey The new aggregation verification key.\n\nevent AggregationVkeyUpdated(\n    bytes32 indexed oldAggregationVkey,\n    bytes32 indexed newAggregationVkey\n);\n</code></pre></p> <p>Errors:</p> <ul> <li>Thrown when new aggregationVKey is 0: <pre><code>error AggregationVkeyMustBeDifferentThanZero();\n</code></pre></li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#16-updaterangevkeycommitment","title":"1.6. updateRangeVkeyCommitment","text":"<p>Function to update the range verification key commitment.</p> <p>Parameters: <pre><code>@param _rangeVkeyCommitment The new range verification key commitment\n</code></pre></p> <p>Events: <pre><code>@param oldRangeVkeyCommitment The old range verification key commitment.\n@param newRangeVkeyCommitment The new range verification key commitment.\nevent RangeVkeyCommitmentUpdated(\n    bytes32 indexed oldRangeVkeyCommitment,\n    bytes32 indexed newRangeVkeyCommitment\n);\n</code></pre></p> <p>Errors:</p> <ul> <li>Thrown when new rangeVkey commitment is 0: <pre><code>error RangeVkeyCommitmentMustBeDifferentThanZero();\n</code></pre></li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#17-updaterollupconfighash","title":"1.7. updateRollupConfigHash","text":"<p>Function to update the rollup config hash.</p> <p>Parameters: <pre><code>@param _rollupConfigHash The new rollup config hash\n</code></pre></p> <p>Events: <pre><code>@param oldRollupConfigHash The old rollup config hash.\n@param newRollupConfigHash The new rollup config hash.\n\nevent RollupConfigHashUpdated(\n    bytes32 indexed oldRollupConfigHash,\n    bytes32 indexed newRollupConfigHash\n) \n</code></pre></p> <p>Errors:</p> <ul> <li>Thrown when rollup config hash is 0 <pre><code>error RollupConfigHashMustBeDifferentThanZero();\n</code></pre></li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#18-enableoptimisticmodedisableoptimisticmode","title":"1.8. enableOptimisticMode/disableOptimisticMode","text":"<p>Functions to enable or disable optimistic mode.</p> <ul> <li> <p><code>enableOptimisticMode</code>:</p> <ul> <li> <p>Events: <pre><code>event EnableOptimisticMode(); \n</code></pre></p> </li> <li> <p>Error:</p> <p>If optimistic mode is enabled <pre><code>error OptimisticModeEnabled();\n</code></pre></p> </li> </ul> </li> <li> <p><code>disableOptimisticMode</code>:</p> <ul> <li> <p>Events: <pre><code>event DisableOptimisticMode();\n</code></pre></p> </li> <li> <p>Error:</p> <p>If optimistic mode is not enabled <pre><code>error OptimisticModeNotEnabled();\n</code></pre></p> </li> </ul> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#19-transferaggchainmanagerroleacceptaggchainmanagerrole","title":"1.9. transferAggchainManagerRole/acceptAggchainManagerRole","text":"<p>Functions to transfer and accept aggchain manager role. </p> <ul> <li> <p><code>transferAggchainManagerRole</code>:</p> <p>Starts the aggchainManager role transfer. This is a two step process, the pending aggchainManager must accept to finalize the process.</p> <ul> <li> <p>Parameters: <pre><code>@param newAggchainManager Address of the new aggchainManager\n</code></pre></p> </li> <li> <p>Events: <pre><code>@param currentAggchainManager The current pending aggchainManager\n@param newPendingAggchainManager The new pending aggchainManager\n\nevent TransferAggchainManagerRole(\n    address currentAggchainManager,\n    address newPendingAggchainManager\n)\n</code></pre></p> </li> </ul> </li> <li> <p><code>acceptAggchainManagerRole</code>:</p> <p>Allow the current pending aggchainManager to accept the aggchainManager role.</p> <ul> <li> <p>Event: <pre><code>@param oldAggchainManager The old aggchainManager\n@param newAggchainManager The new aggchainManager\nevent AcceptAggchainManagerRole(\n    address oldAggchainManager,\n    address newAggchainManager\n)\n</code></pre></p> </li> <li> <p>Error:</p> <p>Thrown when the caller is not the pending aggchain manager <pre><code>error OnlyPendingAggchainManager();\n</code></pre></p> </li> </ul> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#110-transferoptimisticmodemanagerroleacceptoptimisticmodemanagerrole","title":"1.10. transferOptimisticModeManagerRole/acceptOptimisticModeManagerRole","text":"<p>Functions to transfer and accept optimistic mode manager role. </p> <ul> <li> <p><code>transferOptimisticModeManagerRole</code>:</p> <p>Starts the optimisticModeManager role transfer. This is a two step process, the pending optimisticModeManager must accepted to finalize the process.</p> <ul> <li> <p>Parameters: <pre><code>@param newOptimisticModeManager Address of the new optimisticModeManager\n</code></pre></p> </li> <li> <p>Events: <pre><code>@param currentAggchainManager The current pending aggchainManager\n@param newPendingAggchainManager The new pending aggchainManager\n\nevent TransferAggchainManagerRole(\n    address currentAggchainManager,\n    address newPendingAggchainManager\n)\n</code></pre></p> </li> </ul> </li> <li> <p><code>acceptOptimisticModeManagerRole</code>:</p> <p>Allow the current pending optimisticModeManager to accept the optimisticModeManager role.</p> <ul> <li> <p>Event: <pre><code>@param oldOptimisticModeManager The old optimisticModeManager\n@param newOptimisticModeManager The new optimisticModeManager\n\nevent AcceptOptimisticModeManagerRole(\n    address oldOptimisticModeManager,\n    address newOptimisticModeManager\n)\n</code></pre></p> </li> <li> <p>Error:</p> <p>Thrown when the caller is not the pending optimistic mode manager. <pre><code>error OnlyPendingOptimisticModeManager();\n</code></pre></p> </li> </ul> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#2-tooling-available","title":"2. Tooling available","text":""},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#21-change-optimistic-mode","title":"2.1. Change optimistic mode","text":"<p>Tool to change optimistic mode (<code>true/false</code>).</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#22-transfer-aggchain-manager","title":"2.2. Transfer aggchain manager","text":"<p>Tool to transfer and accept aggchain manager role.</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#23-transfer-optimistic-mode-manager-role","title":"2.3. Transfer optimistic mode manager role","text":"<p>Tool to transfer and accept optimistic mode manager role.</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#24-update-rollup-config-hash","title":"2.4. Update rollup config hash","text":"<p>Tool to update rollup config hash.</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#25-update-submission-interval","title":"2.5. Update submission interval","text":"<p>Tool to update submission interval.</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/AggchainFEP/#26-tools-to-get-aggchain-data","title":"2.6. Tools to get aggchain data","text":"<p>Tools to:</p> <ul> <li>Get aggchainData</li> <li>Get initiliaze bytes aggchain v0</li> <li>Get initiliaze bytes aggchain v1</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/PolygonRollupManager/","title":"PolygonRollupManager","text":"<ul> <li>PolygonRollupManager<ul> <li>1. Interactions &amp; Usage<ul> <li>1.1. addNewRollupType</li> <li>1.2. obsoleteRollupType</li> <li>1.3. attachAggchainToAL</li> <li>1.4. addExistingRollup</li> <li>1.5. updateRollupByRollupAdmin</li> <li>1.6. updateRollup</li> <li>1.7. initMigration</li> <li>1.8. rollbackBatches</li> <li>1.9. onSequenceBatches</li> <li>1.10. verifyBatchesTrustedAggregator</li> <li>1.11. verifyPessimisticTrustedAggregator</li> <li>1.12. activateEmergencyState</li> <li>1.13. deactivateEmergencyState</li> <li>1.14. setBatchFee</li> <li>1.15. Getters</li> </ul> </li> <li>2. Tooling available<ul> <li>2.1. addRollupType</li> <li>2.2. createNewRollup</li> <li>2.3. getRollupData</li> <li>2.4. updateRollup</li> </ul> </li> </ul> </li> </ul> <p>Contract responsible for managing rollups and the verification of their batches. This contract will create and update rollups and store all the hashed sequenced data from them. The logic for sequence batches is moved to the <code>consensus</code> contracts, while the verification of all of them will be done in this one. In this way, the proof aggregation of the rollups will be easier on a close future.</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/PolygonRollupManager/#1-interactions-usage","title":"1. Interactions &amp; Usage","text":""},{"location":"aggregation-layer/v0.3.0/SC-interactions/PolygonRollupManager/#11-addnewrolluptype","title":"1.1. addNewRollupType","text":"<p>Function to add a new rollup type.</p> <p>Parameters: <pre><code>@param consensusImplementation Consensus implementation\n@param verifier Verifier address\n@param forkID ForkID of the verifier\n@param rollupVerifierType rollup verifier type\n@param genesis Genesis block of the rollup\n@param description Description of the rollup type\n@param programVKey Hashed program that will be executed in case of using a \"general purpose ZK verifier\" e.g SP1\n</code></pre></p> <p>Events: <pre><code>event AddNewRollupType(\n    uint32 indexed rollupTypeID,\n    address consensusImplementation,\n    address verifier,\n    uint64 forkID,\n    VerifierType rollupVerifierType,\n    bytes32 genesis,\n    string description,\n    bytes32 programVKey\n);\n</code></pre></p> <p>Errors:</p> <ul> <li>Invalid Rollup type parameters: <pre><code>error InvalidRollupType();\n</code></pre></li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/PolygonRollupManager/#12-obsoleterolluptype","title":"1.2. obsoleteRollupType","text":"<p>Function to obsolete Rollup type.</p> <p>Parameters: <pre><code>@param rollupTypeID Rollup type to obsolete\n</code></pre></p> <p>Events: <pre><code>event ObsoleteRollupType(uint32 indexed rollupTypeID);\n</code></pre></p> <p>Errors:</p> <ul> <li> <p>When a rollup type does not exist: <pre><code>error RollupTypeDoesNotExist();\n</code></pre></p> </li> <li> <p>When a rollup type is obsoleted: <pre><code>error RollupTypeObsolete();\n</code></pre></p> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/PolygonRollupManager/#13-attachaggchaintoal","title":"1.3. attachAggchainToAL","text":"<p>Function to create a new rollup.</p> <p>Parameters: <pre><code>@param rollupTypeID Rollup type to deploy\n@param chainID ChainID of the rollup, must be a new one, can not have more than 32 bits\n@param initializeBytesAggchain Encoded params to initialize the chain. Each aggchain has its encoded params.\n@dev in case of rollupType state transition or pessimistic, the encoded params are the following: (address admin, address sequencer, address gasTokenAddress, string sequencerURL, string networkName)\n</code></pre></p> <p>Events:</p> <ul> <li> <p>Emitted when a new rollup is created based on a rollupType <pre><code>event CreateNewAggchain(\n    uint32 indexed rollupID,\n    uint32 rollupTypeID,\n    address rollupAddress,\n    uint64 chainID,\n    uint8 rollupVerifierType,\n    bytes initializeBytesAggchain\n)\n</code></pre></p> </li> <li> <p>Emitted when a new rollup is created based on a rollupType <pre><code>event CreateNewRollup(\n    uint32 indexed rollupID,\n    uint32 rollupTypeID,\n    address rollupAddress,\n    uint64 chainID,\n    address gasTokenAddress\n)\n</code></pre></p> </li> </ul> <p>Errors:</p> <ul> <li> <p>When a rollup type does not exist: <pre><code>error RollupTypeDoesNotExist();\n</code></pre></p> </li> <li> <p>When a rollup type is obsoleted: <pre><code>error RollupTypeObsolete();\n</code></pre></p> </li> <li> <p>When try to create a new rollup and set a chainID bigger than 32 bits: <pre><code>error ChainIDOutOfRange();\n</code></pre></p> </li> <li> <p>Thrown when the caller is not the pending admin: <pre><code>error ChainIDAlreadyExist();\n</code></pre></p> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/PolygonRollupManager/#14-addexistingrollup","title":"1.4. addExistingRollup","text":"<p>Function to add an already deployed rollup-</p> <p>Parameters: <pre><code>@param rollupAddress Rollup address\n@param verifier Verifier address, must be added before\n@param forkID Fork id of the added rollup\n@param chainID Chain id of the added rollup\n@param initRoot Genesis block for StateTransitionChains &amp; localExitRoot for pessimistic chain\n@param rollupVerifierType Compatibility ID for the added rollup\n@param programVKey Hashed program that will be executed in case of using a \"general purpose ZK verifier\" e.g SP1\n@param initPessimisticRoot Pessimistic root to init the chain.\n</code></pre></p> <p>Events: <pre><code>event AddExistingRollup(\n    uint32 indexed rollupID,\n    uint64 forkID,\n    address rollupAddress,\n    uint64 chainID,\n    VerifierType rollupVerifierType,\n    uint64 lastVerifiedBatchBeforeUpgrade,\n    bytes32 programVKey,\n    bytes32 initPessimisticRoot\n)\n</code></pre></p> <p>Errors:</p> <ul> <li> <p>Thrown when chainID already exist: <pre><code>error ChainIDAlreadyExist();\n</code></pre></p> </li> <li> <p>When try to create a new rollup and set a chainID bigger than 32 bits: <pre><code>error ChainIDOutOfRange();\n</code></pre></p> </li> <li> <p>When adding an existing rollup where the rollup address already was added <pre><code>error RollupAddressAlreadyExist();\n</code></pre></p> </li> <li> <p>Thrown when trying to create a rollup but the input parameters are not  according with the chosen rollupType <pre><code>error InvalidInputsForRollupType();\n</code></pre></p> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/PolygonRollupManager/#15-updaterollupbyrollupadmin","title":"1.5. updateRollupByRollupAdmin","text":"<p>Function to Upgrade an existing rollup from the rollup admin address. This address is able to update the rollup with more restrictions that the _UPDATE_ROLLUP_ROLE.</p> <p>Parameters: <pre><code>@param rollupContract Rollup consensus proxy address\n@param newRollupTypeID New rollupTypeID to upgrade to\n</code></pre></p> <p>Events: <pre><code>event UpdateRollup(\n    uint32 indexed rollupID,\n    uint32 newRollupTypeID,\n    uint64 lastVerifiedBatchBeforeUpgrade\n);\n</code></pre></p> <p>Errors:</p> <ul> <li> <p>When try to upgrade a rollup a sender that's not the admin of the rollup <pre><code>error OnlyRollupAdmin();\n</code></pre></p> </li> <li> <p>When try to update a rollup with sequences pending to verify <pre><code>error AllSequencedMustBeVerified();\n</code></pre></p> </li> <li> <p>Update to old rollup ID: <pre><code>error UpdateToOldRollupTypeID();\n</code></pre></p> </li> <li> <p>When update to not compatible rollup type: <pre><code>error UpdateNotCompatible();\n</code></pre></p> </li> <li> <p>When a rollup type does not exist: <pre><code>error RollupTypeDoesNotExist();\n</code></pre></p> </li> <li> <p>When rollup does not exist: <pre><code>error RollupMustExist();\n</code></pre></p> </li> <li> <p>When old rollupTypeID is newRollupTypeID <pre><code>error UpdateToSameRollupTypeID();\n</code></pre></p> </li> <li> <p>When a rollup type is obsoleted: <pre><code>error RollupTypeObsolete();\n</code></pre></p> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/PolygonRollupManager/#16-updaterollup","title":"1.6. updateRollup","text":"<p>Function to upgrade an existing rollup.</p> <p>Parameters: <pre><code>@param rollupContract Rollup consensus proxy address\n@param newRollupTypeID New rollupTypeID to upgrade to\n@param upgradeData Upgrade data\n</code></pre></p> <p>Events: <pre><code>event UpdateRollup(\n    uint32 indexed rollupID,\n    uint32 newRollupTypeID,\n    uint64 lastVerifiedBatchBeforeUpgrade\n);\n</code></pre></p> <p>Errors: - When a rollup type does not exist: <pre><code>error RollupTypeDoesNotExist();\n</code></pre></p> <ul> <li> <p>When rollup does not exist: <pre><code>error RollupMustExist();\n</code></pre></p> </li> <li> <p>When old rollupTypeID is newRollupTypeID <pre><code>error UpdateToSameRollupTypeID();\n</code></pre></p> </li> <li> <p>When a rollup type is obsoleted: <pre><code>error RollupTypeObsolete();\n</code></pre></p> </li> <li> <p>When update to not compatible rollup type <pre><code>error UpdateNotCompatible();\n</code></pre></p> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/PolygonRollupManager/#17-initmigration","title":"1.7. initMigration","text":"<p>Function to init migration to PP or ALGateway.</p> <p>Parameters: <pre><code>@param rollupID Rollup ID that is being migrated\n@param newRollupTypeID New rollup type ID that the rollup will be migrated to\n@param upgradeData Upgrade data\n</code></pre></p> <p>Events: <pre><code>event InitMigration(\n    uint32 indexed rollupID,\n    uint32 newRollupTypeID\n);\n</code></pre></p> <p>Errors:</p> <ul> <li> <p>Only for StateTransition chains: <pre><code>error OnlyStateTransitionChains();\n</code></pre></p> </li> <li> <p>No pending batches to verify allowed before migration: <pre><code>error AllSequencedMustBeVerified();\n</code></pre></p> </li> <li> <p>NewRollupType must be pessimistic or ALGateway: <pre><code>error NewRollupTypeMustBePessimisticOrALGateway();\n</code></pre></p> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/PolygonRollupManager/#18-rollbackbatches","title":"1.8. rollbackBatches","text":"<p>Function to batches of the target rollup (Only applies to state transition rollups).</p> <p>Parameters: <pre><code>@param rollupContract Rollup consensus proxy address\n@param targetBatch Batch to rollback up to but not including this batch\n</code></pre></p> <p>Events: <pre><code>event RollbackBatches(\n    uint32 indexed rollupID,\n    uint64 indexed targetBatch,\n    bytes32 accInputHashToRollback\n);\n</code></pre></p> <p>Errors:</p> <ul> <li> <p><code>rollbackBatches</code> is called from a non authorized address: <pre><code>error NotAllowedAddress();\n</code></pre></p> </li> <li> <p>Thrown when rollup does not exist: <pre><code>error RollupMustExist();\n</code></pre></p> </li> <li> <p>When rollup isn't state transition type: <pre><code>error OnlyStateTransitionChains();\n</code></pre></p> </li> <li> <p>Rollback batch is not sequenced: <pre><code>error RollbackBatchIsNotValid();\n</code></pre></p> </li> <li> <p>Rollback batch is not the end of any sequence <pre><code>error RollbackBatchIsNotEndOfSequence();\n</code></pre></p> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/PolygonRollupManager/#19-onsequencebatches","title":"1.9. onSequenceBatches","text":"<p>Function to sequence batches, callback called by one of the consensus managed by this contract.</p> <p>Parameters: <pre><code>@param newSequencedBatches Number of batches sequenced\n@param newAccInputHash New accumulate input hash\n</code></pre></p> <p>Events: <pre><code>event OnSequenceBatches(\n    uint32 indexed rollupID,\n    uint64 lastBatchSequenced\n);\n</code></pre></p> <p>Errors:</p> <ul> <li> <p>Thrown when sender isn't a rollup <pre><code>error SenderMustBeRollup();\n</code></pre></p> </li> <li> <p>Thrown when <code>newSequencedBatches</code> = 0 <pre><code>error MustSequenceSomeBatch();\n</code></pre></p> </li> <li> <p>When rollup isn't state transition type: <pre><code>error OnlyStateTransitionChains();\n</code></pre></p> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/PolygonRollupManager/#110-verifybatchestrustedaggregator","title":"1.10. verifyBatchesTrustedAggregator","text":"<p>Allows a trusted aggregator to verify multiple batches-</p> <p>Parameters: <pre><code>@param rollupID Rollup identifier\n@param pendingStateNum Init pending state, 0 if consolidated state is used (deprecated)\n@param initNumBatch Batch which the aggregator starts the verification\n@param finalNewBatch Last batch aggregator intends to verify\n@param newLocalExitRoot New local exit root once the batch is processed\n@param newStateRoot New State root once the batch is processed\n@param beneficiary Address that will receive the verification reward\n@param proof Fflonk proof\n</code></pre></p> <p>Events: <pre><code>event VerifyBatchesTrustedAggregator(\n    uint32 indexed rollupID,\n    uint64 numBatch,\n    bytes32 stateRoot,\n    bytes32 exitRoot,\n    address indexed aggregator\n)\n</code></pre></p> <p>Errors:</p> <ul> <li> <p>Pending state num exist: <pre><code>error PendingStateNumExist();\n</code></pre></p> </li> <li> <p>When rollup isn't state transition type: <pre><code>error OnlyStateTransitionChains();\n</code></pre></p> </li> <li> <p>When initNumBatch is lower than last verified batch before upgrade: <pre><code>error InitBatchMustMatchCurrentForkID();\n</code></pre></p> </li> <li> <p>Thrown when the old state root of a certain batch does not exist: <pre><code>error OldStateRootDoesNotExist();\n</code></pre></p> </li> <li> <p>Thrown when the init verification batch is above the last verification batch: <pre><code>error InitNumBatchAboveLastVerifiedBatch();\n</code></pre></p> </li> <li> <p>Thrown when the final verification batch is below or equal the last verification batch: <pre><code>error FinalNumBatchBelowLastVerifiedBatch();\n</code></pre></p> </li> <li> <p>Thrown when the old accumulate input hash does not exist: <pre><code>error OldAccInputHashDoesNotExist();\n</code></pre></p> </li> <li> <p>Thrown when the new accumulate input hash does not exist: <pre><code>error NewAccInputHashDoesNotExist();\n</code></pre></p> </li> <li> <p>Thrown when the new state root is not inside prime: <pre><code>error NewStateRootNotInsidePrime();\n</code></pre></p> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/PolygonRollupManager/#111-verifypessimistictrustedaggregator","title":"1.11. verifyPessimisticTrustedAggregator","text":"<p>Allows a trusted aggregator to verify pessimistic proof.</p> <p>Parameters: <pre><code>@param rollupID Rollup identifier\n@param l1InfoTreeLeafCount Count of the L1InfoTree leaf that will be used to verify imported bridge exits\n@param newLocalExitRoot New local exit root\n@param newPessimisticRoot New pessimistic information, Hash(localBalanceTreeRoot, nullifierTreeRoot)\n@param proof SP1 proof (Plonk)\n@param aggchainData Specific custom data to verify Aggregation layer chains\n</code></pre></p> <p>Events:</p> <pre><code>event VerifyBatchesTrustedAggregator(\n    uint32 indexed rollupID,\n    uint64 numBatch,\n    bytes32 stateRoot,\n    bytes32 exitRoot,\n    address indexed aggregator\n);\n\nevent VerifyPessimisticStateTransition(\n    uint32 indexed rollupID,\n    bytes32 prevPessimisticRoot,\n    bytes32 newPessimisticRoot,\n    bytes32 prevLocalExitRoot,\n    bytes32 newLocalExitRoot,\n    bytes32 l1InfoRoot,\n    address indexed trustedAggregator\n);\n</code></pre> <ul> <li>If it's a migration: <pre><code>event CompletedMigration(uint32 indexed rollupID);\n</code></pre></li> </ul> <p>Errors:</p> <ul> <li> <p>Thrown when a function is executed for a State transition chains when it is not allowed: <pre><code>error StateTransitionChainsNotAllowed();\n</code></pre></p> </li> <li> <p>Custom chain data must be zero for pessimistic verifier type: <pre><code>error AggchainDataMustBeZeroForPessimisticVerifierType();\n</code></pre></p> </li> <li> <p>Not valid L1 info tree leaf count: <pre><code>error L1InfoTreeLeafCountInvalid();\n</code></pre></p> </li> <li> <p>If it's a migration, it's a hard requirement that the newLocalExitRoot matches the current lastLocalExitRoot meaning that the certificates covers all the bridges: <pre><code>error InvalidNewLocalExitRoot();\n</code></pre></p> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/PolygonRollupManager/#112-activateemergencystate","title":"1.12. activateEmergencyState","text":"<p>Function to activate emergency state, which also enables the emergency mode on both PolygonRollupManager and PolygonZkEVMBridge contracts.</p> <p>Events: <pre><code>emit EmergencyStateActivated();\n</code></pre></p> <p>Errors:</p> <ul> <li> <p>Thrown when the halt timeout is not expired when attempting to activate the emergency state: <pre><code>error HaltTimeoutNotExpired();\n</code></pre></p> </li> <li> <p>Only allows a function to be callable if emergency state is unactive: <pre><code>error OnlyNotEmergencyState();\n</code></pre></p> </li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/PolygonRollupManager/#113-deactivateemergencystate","title":"1.13. deactivateEmergencyState","text":"<p>Function to deactivate emergency state on both PolygonRollupManager and PolygonZkEVMBridge contracts.</p> <p>Events: <pre><code>emit EmergencyStateDeactivated();\n</code></pre></p> <p>Errors:</p> <ul> <li>Only allows a function to be callable if emergency state is active: <pre><code>error OnlyEmergencyState();\n</code></pre></li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/PolygonRollupManager/#114-setbatchfee","title":"1.14. setBatchFee","text":"<p>Function to set the current batch fee.</p> <p>Parameters: <pre><code>@param newBatchFee new batch fee\n</code></pre></p> <p>Events: <pre><code>emit SetBatchFee(newBatchFee);\n</code></pre></p> <p>Errors:</p> <ul> <li>When batch fee isn't within the limits: <pre><code>error BatchFeeOutOfRange();\n</code></pre></li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/PolygonRollupManager/#115-getters","title":"1.15. Getters","text":"<ul> <li>getRollupExitRoot</li> <li>getLastVerifiedBatch</li> <li>calculateRewardPerBatch</li> <li>getBatchFee</li> <li>getForcedBatchFee</li> <li>getInputPessimisticBytes</li> <li>getInputSnarkBytes</li> <li>getRollupBatchNumToStateRoot</li> <li>getRollupSequencedBatches</li> <li>rollupIDToRollupData</li> <li>rollupIDToRollupDataDeserialized</li> <li>rollupIDToRollupDataV2</li> <li>rollupIDToRollupDataV2Deserialized</li> </ul>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/PolygonRollupManager/#2-tooling-available","title":"2. Tooling available","text":""},{"location":"aggregation-layer/v0.3.0/SC-interactions/PolygonRollupManager/#21-addrolluptype","title":"2.1. addRollupType","text":"<p>Tool to add new rollup type.</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/PolygonRollupManager/#22-createnewrollup","title":"2.2. createNewRollup","text":"<p>Tool to create new rollup.</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/PolygonRollupManager/#23-getrollupdata","title":"2.3. getRollupData","text":"<p>Tool to get rollup data.</p>"},{"location":"aggregation-layer/v0.3.0/SC-interactions/PolygonRollupManager/#24-updaterollup","title":"2.4. updateRollup","text":"<p>Tool to update rollup.</p>"},{"location":"tooling/Genesis/","title":"2.2. Genesis creation","text":"<ul> <li>Glossary</li> <li>Chains types</li> <li>Table</li> <li>Extra notes</li> </ul>"},{"location":"tooling/Genesis/#glossary","title":"Glossary","text":"<ul> <li><code>sovereign chain</code>: chain that ONLY uses the pessimistic proof and has NOT any state-transition proof</li> <li><code>sovereign contracts</code>: smart contracts to be used by vanilla clients (i.e. clients that does not have the necessary code to insert GER natively)</li> <li><code>rollupTypeID</code>: it forces rollup parameters when the rollup is created<ul> <li><code>legacy</code>: forces the genesis root</li> <li><code>sovereign</code>: genesis root is not forced (it is <code>0x00..000</code>)</li> </ul> </li> <li><code>timelock admin</code>: setup timelock administration address and its delay. Timelock controls upgrades over the L2 contracts (Bridge &amp; GERManager)</li> <li><code>premint account</code>: Initial pre minted account to be able to do a very first bridge claim</li> </ul>"},{"location":"tooling/Genesis/#chains-types","title":"Chains types","text":"<ul> <li><code>legacy</code>: Hermez prover based chains (zkEVM, Validums)</li> <li><code>sovereign erigon</code>: sovereign chain with cdk-sovereign-erigon client</li> <li><code>sovereign vanilla</code>: sovereign chain with a vanilla client</li> </ul>"},{"location":"tooling/Genesis/#table","title":"Table","text":"from rollupTypeID Bridge initialization SovereignContracts timelock admin premint account legacy \ud83d\udfe2 Decentralized injected batch \u274c \u274c \u274c sovereign erigon \u274c Centralized injected batch \u274c \u274c \u274c sovereign vanilla \u274c Embedded in the genesis \ud83d\udfe2 \ud83d\udfe2 \ud83d\udfe2"},{"location":"tooling/Genesis/#extra-notes","title":"Extra notes","text":"<ul> <li><code>legacy</code>: genesis<code>on</code>legacy<code>chains is created beforehand the chain is created. It is set when the</code>rollupTypeID` is created</li> <li><code>sovereign erigon</code>:<ul> <li>select a <code>genesis-base</code> based on the network (sepolia, mainnet) &amp; RollupManager address (<code>genesis-base</code> is the genesis that has been used by <code>legacy</code> chains)</li> <li>once the rollup is created, the Smart contract assigns a <code>rollupID</code> to the rollup</li> <li>create <code>injected batch</code> data and add it to the client as metadata</li> </ul> </li> <li><code>sovereign vanilla</code><ul> <li>select a <code>genesis-base</code> based on the network (sepolia, mainnet) &amp; RollupManager address (<code>genesis-base</code> is the genesis that has been used by <code>legacy</code> chains)</li> <li>upgrade <code>genesis-base</code> contracts in order to have <code>sovereign contracts</code></li> <li>upgrade <code>genesis-base</code> contracts in order to have a pre-mint account and setup its timelock security</li> </ul> </li> </ul>"},{"location":"tooling/Resources/","title":"Resources","text":"<ul> <li>Steps to update a rollup: new verififer + addNewRollupType + updateRollup</li> <li>Guide to upgrade PolygonRollupManager and GlobalExitRootManager to Banana version fork.12)</li> </ul>"},{"location":"zkEVM/banana-specs/","title":"Specification","text":""},{"location":"zkEVM/banana-specs/#motivation","title":"Motivation","text":"<ul> <li>Stability current forkid.9</li> <li>Minimal resilient features</li> <li>Allow sequence and proving in the same transaction</li> </ul>"},{"location":"zkEVM/banana-specs/#resources","title":"Resources","text":"<ul> <li>SC implementation</li> <li>ROM fix error cold address</li> <li>Full-tracer fix error logs</li> <li>Banana implication for CDKs</li> <li>Proposal design rollback sequences</li> <li>List bugs executor past and current</li> <li>Slides</li> </ul>"},{"location":"zkEVM/banana-specs/#list-changes","title":"List changes","text":"<ul> <li>Rollback sequences</li> <li>Deterministic <code>l1InfoTreeRoot</code></li> <li>Verify <code>accumulate Input Hash</code></li> <li>Fix cold address access</li> <li>Fix issues <code>geth blockhash</code> padding 32 bytes</li> <li>Suggestions resilience</li> <li>New events</li> </ul>"},{"location":"zkEVM/banana-specs/#rollback-sequences","title":"Rollback sequences","text":""},{"location":"zkEVM/banana-specs/#description","title":"Description","text":"<ul> <li>Sequencer commits DA to L1 via the <code>sequenceBatches</code> SC call. When data is commited, the aggregator needs to verify that data</li> <li>This implies that posting some wrong data to L1 may imply a re-org on L2 or the stop of the network verification (pausing withdrawals and emergency upgrade)</li> <li>This feature adds the possibility to delete commit data posted to L1, so the recovery is straightforward causing less outage of the network</li> </ul>"},{"location":"zkEVM/banana-specs/#implementation","title":"Implementation","text":"<ul> <li>https://github.com/0xPolygonHermez/zkevm-contracts/blob/v7.0.0-rc.1-fork.10/contracts/v2/PolygonRollupManager.sol#L737</li> </ul>"},{"location":"zkEVM/banana-specs/#implications","title":"Implications","text":"<ul> <li>Synchronizer should detect the new event emitted and apply it to the virtual state</li> <li>A verifed state cannot be rolled back</li> </ul>"},{"location":"zkEVM/banana-specs/#resources_1","title":"Resources","text":"<ul> <li>Proposal design rollback sequences</li> </ul>"},{"location":"zkEVM/banana-specs/#deterministic-l1infotreeroot","title":"Deterministic <code>l1InfoTreeRoot</code>","text":""},{"location":"zkEVM/banana-specs/#description_1","title":"Description","text":"<ul> <li>Current protocol selects the <code>l1InfoRoot</code> when the <code>sequenceBatches</code> call is done. This approach is optimal in terms of GAS saving but it implies that the <code>accInputHash</code> is non-deterministic</li> <li>This has been an issue when the sequencer does not correctly select the proper <code>indexL1InfoTree</code> or the synchronization could be wrong</li> <li>This feature implies that it will be a mapping containing all the <code>l1InfoRoot</code> in the SC</li> <li>The sequencer will be able to select one of them when sequence a batch</li> </ul>"},{"location":"zkEVM/banana-specs/#implementation_1","title":"Implementation","text":"<ul> <li>https://github.com/0xPolygonHermez/zkevm-contracts/blob/v7.0.0-rc.1-fork.10/contracts/v2/lib/PolygonRollupBaseEtrog.sol#L415</li> <li>https://github.com/0xPolygonHermez/zkevm-contracts/blob/v7.0.0-rc.1-fork.10/contracts/v2/lib/PolygonRollupBaseEtrog.sol#L440</li> <li>https://github.com/0xPolygonHermez/zkevm-contracts/blob/v7.0.0-rc.1-fork.10/contracts/v2/lib/PolygonRollupBaseEtrog.sol#L444</li> </ul>"},{"location":"zkEVM/banana-specs/#implications_1","title":"Implications","text":"<ul> <li><code>sequence-sender</code> to choose the <code>indexL1InfoRoot</code> to verify all the imported <code>GERs</code> in the <code>changeL2Block</code> transactions</li> <li><code>indexL1InfoRoot</code> must exist on the SC. Otherwise, the SC reverts <p>tip: choose the last <code>indexL1InfoRoot</code> that has been added in a finalized etheruem block tip: <code>sequence-sender</code> to perform a sanity-check when choosing the <code>indexL1InfoRoot</code>. Get all the <code>indexL1InfoTree</code> in the full sequence, with its corresponding data and check that indeed matches against the selected <code>l1InfoTreeRoot</code> selected</p> </li> </ul>"},{"location":"zkEVM/banana-specs/#verify-accumulate-input-hash","title":"Verify <code>accumulate Input Hash</code>","text":""},{"location":"zkEVM/banana-specs/#description_2","title":"Description","text":"<ul> <li>Assuming <code>l1InfoTreeRoot</code> is deterministic, the sequencer can now pre-compute the <code>accInputHash</code> in advance</li> <li>The <code>accInputHash</code> is a summary of all the data processed in L2. Therefore, it acts as a sanity check when sequencing batches in L1</li> </ul>"},{"location":"zkEVM/banana-specs/#implementation_2","title":"Implementation","text":"<ul> <li>https://github.com/0xPolygonHermez/zkevm-contracts/blob/v7.0.0-rc.1-fork.10/contracts/v2/lib/PolygonRollupBaseEtrog.sol#L417</li> <li>https://github.com/0xPolygonHermez/zkevm-contracts/blob/v7.0.0-rc.1-fork.10/contracts/v2/lib/PolygonRollupBaseEtrog.sol#L563</li> <li>JS accInputHash</li> <li>Go implementation accInputHash</li> </ul>"},{"location":"zkEVM/banana-specs/#implications_2","title":"Implications","text":"<ul> <li><code>sequence-sender</code> needs to compute the <code>accInputHash</code> and send it to L1 <p>tip: if transaction reverts for this reason, it means that the data processed by the trsuted-sequencer and the one sent by the sequence-sender is different. Some sort of alarm/notification should be trigerred</p> </li> </ul>"},{"location":"zkEVM/banana-specs/#fix-cold-address-access","title":"Fix cold address access","text":""},{"location":"zkEVM/banana-specs/#description_3","title":"Description","text":"<ul> <li>Even if <code>create</code>/<code>create2</code> operation fails, the computed address will remain in the warm addresses set</li> <li>Full isues with details: https://github.com/0xPolygonHermez/zkevm-rom/issues/389</li> </ul>"},{"location":"zkEVM/banana-specs/#implementation_3","title":"Implementation","text":"<ul> <li>https://github.com/0xPolygonHermez/zkevm-rom/pull/390</li> </ul>"},{"location":"zkEVM/banana-specs/#implications_3","title":"Implications","text":"<ul> <li>execution to mimic zkEVM ROM</li> </ul>"},{"location":"zkEVM/banana-specs/#fix-issues-geth-blockhash-padding-32-bytes","title":"Fix issues <code>geth blockhash</code> padding 32 bytes","text":""},{"location":"zkEVM/banana-specs/#description_4","title":"Description","text":"<ul> <li>Logs not padded to 32 bytes are not correctky returned by the full-tracer to the sequencer</li> <li>Sequencer computes and stores logs based on full-tracer response</li> <li>There is a current mismatch of the logs stored on L2 and the logs stored on the node</li> </ul>"},{"location":"zkEVM/banana-specs/#implementation_4","title":"Implementation","text":"<ul> <li>https://github.com/0xPolygonHermez/zkevm-prover/commit/23cf552758bd76fca0de8419cdfdabbe3c3d384f</li> </ul>"},{"location":"zkEVM/banana-specs/#implications_4","title":"Implications","text":"<ul> <li>execution to mimic zkEVM ROM</li> </ul>"},{"location":"zkEVM/banana-specs/#suggestions-resilience","title":"Suggestions resilience","text":"<ul> <li>sanity check <code>expectedNewStateRoot</code><ul> <li>before verifying the batch to L1<ul> <li>trusted sequencer to provide its computed <code>state-root</code></li> <li>execute aggregator and aggregator to detect possible state-root differences</li> <li>if this happens --&gt; alarm/notification<ul> <li>most probably a re-org or rollback sequences may be needed</li> </ul> </li> </ul> </li> </ul> </li> <li>detect change <code>l2Coinbase</code> at <code>sequence-sender</code> level<ul> <li>there is only one <code>l2Coinbase</code> per each sequence (multiple batches)</li> <li>a new sequence needs to be creared if the <code>l2Coinbase</code> is chnaged</li> </ul> </li> </ul>"},{"location":"zkEVM/banana-specs/#new-events","title":"New events","text":""},{"location":"zkEVM/banana-specs/#description_5","title":"Description","text":"<ul> <li>Add <code>l1InfoTree</code> leaf information into an  new event</li> </ul>"},{"location":"zkEVM/banana-specs/#implementation_5","title":"Implementation","text":"<ul> <li>https://github.com/0xPolygonHermez/zkevm-contracts/blob/feature/update-l1-info-tree-v2/contracts/v2/PolygonZkEVMGlobalExitRootV2.sol#L39</li> </ul>"},{"location":"zkEVM/banana-specs/#implications_5","title":"Implications","text":"<ul> <li>Adds costs for every deposit</li> <li>Enable to synchronize <code>l1InfoRoot</code> from events</li> <li>Does not break compatibility for <code>bridge-service</code></li> </ul>"},{"location":"zkEVM/durian-specs/","title":"Specification","text":""},{"location":"zkEVM/durian-specs/#motivation","title":"Motivation","text":""},{"location":"zkEVM/durian-specs/#precompiled-modexp","title":"Precompiled modexp","text":"<ul> <li>The precompiled modexp is enabled: modexp<ul> <li>some fixes regarding the previous version have been added</li> <li>after a few discussions, it is decided to set the maximum input length of the base, modulus and exponent to 32 chunks of 256 bits. See link for more details</li> <li>if input length &gt; %MAX_SIZE_MODEXP --&gt; zkEVM does a revert returning all the gas consumed</li> </ul> </li> </ul>"},{"location":"zkEVM/durian-specs/#rip7212-p256verify","title":"RIP7212: p256verify","text":"<p>A precompiled contract that perfoms signature verifications in the <code>secp256r1</code> elliptic curve have been added: rip7212</p>"},{"location":"zkEVM/durian-specs/#tags","title":"Tags","text":"<ul> <li>zkevm-rom: <code>v9.0.0-rc.2-fork.13</code></li> <li>zkevm-testvectors: <code>v9.0.0-rc.3-fork.13</code></li> <li>zkevm-commonjs: <code>v9.0.0-rc.3-fork.13</code></li> <li>zkevm-proverjs:</li> </ul>"},{"location":"zkEVM/durian-specs/#git-diff","title":"git diff","text":"<ul> <li>zkevm-rom: PR develop-durian</li> <li>zkevm-testvectors: PR develop-durian</li> <li>zkevm-commonjs: PR develop-durian</li> <li>zkevm-proverjs:</li> </ul>"},{"location":"zkEVM/durian-specs/#code-changes","title":"Code changes","text":""},{"location":"zkEVM/durian-specs/#zkevm-rom","title":"zkevm-rom","text":"<ul> <li>Update constant <code>forkId</code>: <pre><code>CONST %FORK_ID = 13\n</code></pre></li> </ul>"},{"location":"zkEVM/durian-specs/#modexp","title":"Modexp","text":"<ul> <li>Update selector precompiled: <pre><code>A - 6               :JMPN(funcModexp)\n</code></pre></li> <li>Update pre-modexp with fixes: pre-modexp changes + fix</li> <li>Modexp Update: PR modexp durian</li> </ul>"},{"location":"zkEVM/durian-specs/#p256verify","title":"p256verify","text":"<ul> <li>Add new address precompiled:<ul> <li><code>process-tx.zkasm</code>: <pre><code>; Check zero address since zero address is not a precompiled contract\n    0 =&gt; B\n    $                               :EQ, JMPC(callContract)\n    0x100 =&gt; B\n    $                               :EQ, JMPC(selectorPrecompiledP256Verify)\n    10 =&gt; B\n    $                               :LT,JMPC(selectorPrecompiled, callContract)\n    $                               :LT, JMPC(selectorPrecompiled, callContract)\n</code></pre></li> <li><code>precompiled/selector.zkasm</code>: <pre><code>selectorPrecompiledP256Verify:\n                    :JMP(funcP256VERIFY)\n</code></pre></li> </ul> </li> <li>Add pre-p256verify:<ul> <li><code>constants.zkasm</code>: <pre><code>CONST %P256VERIFY_GAS = 3450 ; p256verify gas price\n</code></pre></li> <li><code>precompiled/pre-p256verify.zkasm</code>: file</li> <li>Update <code>isColdAddress</code> (<code>touched.zkasm</code>): <pre><code>; if address is a precompiled considered as warm address\n10 =&gt; B\n$                           :LT, JMPC(finishColdPrecompiled)\n0x100 =&gt; B\n$                           :EQ, JMPC(finishColdPrecompiled)\n</code></pre></li> <li>Update counters: commit counters</li> </ul> </li> <li>Add <code>p256verify</code>: PR p256verify</li> </ul>"},{"location":"zkEVM/durian-specs/#zkevm-proverjs","title":"zkevm-proverjs","text":"<ul> <li>PR develop-durian</li> </ul>"},{"location":"zkEVM/durian-specs/#zkevm-testvectors","title":"zkevm-testvectors","text":"<ul> <li>Update tests forkId = 13</li> <li>Update pre-revert tests (delete modexp)</li> <li>Add tests modexp</li> <li>Add tests p256verify</li> <li>Update tests with 0x100 address in <code>pre-state</code> (ethereum-tests)</li> <li>Update virtual counters</li> </ul>"},{"location":"zkEVM/durian-specs/#zkevm-commonjs","title":"zkevm-commonjs","text":"<ul> <li>Update monorepo version</li> <li>Update VCs:<ul> <li>VCs <code>p256verify</code>: file</li> <li>VCs <code>modexp</code>: file &amp; utils</li> </ul> </li> </ul>"},{"location":"zkEVM/durian-specs/#fork-ethereumjs-monorepo","title":"fork ethereumjs-monorepo","text":"<ul> <li>Update p256verify gas cost: commit</li> <li>RIP 7212 implementation: commit + fix</li> <li>Update VCs RIP7212: commit</li> </ul>"}]}